/*!
  credify-crypto.js v1.4.4
  https://developers.credify.one
  Released under the MIT License.
*/
'use strict';

var webcrypto = require('@peculiar/webcrypto');
var cryptoKeyComposer = require('@credify/crypto-key-composer');
var crypto$1 = require('crypto');
var nodeForge = require('node-forge');
var HDKey = require('hdkey');
var bip39 = require('bip39');
var wif = require('wif');
var elliptic = require('elliptic');
var eosjsJssig = require('eosjs/dist/eosjs-jssig');
var eosjsNumeric = require('eosjs/dist/eosjs-numeric');

var _assign = function __assign() {
  _assign = Object.assign || function __assign(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];

      for (var p in s) {
        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
      }
    }

    return t;
  };

  return _assign.apply(this, arguments);
};
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }

  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _ = {
    label: 0,
    sent: function sent() {
      if (t[0] & 1) throw t[1];
      return t[1];
    },
    trys: [],
    ops: []
  },
      f,
      y,
      t,
      g;
  return g = {
    next: verb(0),
    "throw": verb(1),
    "return": verb(2)
  }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
    return this;
  }), g;

  function verb(n) {
    return function (v) {
      return step([n, v]);
    };
  }

  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");

    while (_) {
      try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
        if (y = 0, t) op = [op[0] & 2, t.value];

        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;

          case 4:
            _.label++;
            return {
              value: op[1],
              done: false
            };

          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;

          case 7:
            op = _.ops.pop();

            _.trys.pop();

            continue;

          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }

            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }

            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }

            if (t && _.label < t[2]) {
              _.label = t[2];

              _.ops.push(op);

              break;
            }

            if (t[2]) _.ops.pop();

            _.trys.pop();

            continue;
        }

        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
    }

    if (op[0] & 5) throw op[1];
    return {
      value: op[0] ? op[1] : void 0,
      done: true
    };
  }
}

var headerPrivateKey = "-----BEGIN PRIVATE KEY-----\n";
var footerPrivateKey = "\n-----END PRIVATE KEY-----";
var headerPublicKey = "-----BEGIN PUBLIC KEY-----\n";
var footerPublicKey = "\n-----END PUBLIC KEY-----";
var isArray = function (a) {
    return Array.isArray(a);
};
var isObject = function (o) {
    return o === Object(o) && !isArray(o) && typeof o !== "function";
};
var sha256 = function (value) {
    if (isObject(value) || isArray(value)) {
        var base64_1 = crypto$1.createHash("sha256")
            .update(JSON.stringify(value))
            .digest("base64");
        return base64ToBase64UrlEncoded(base64_1);
    }
    var base64 = crypto$1.createHash("sha256").update(value).digest("base64");
    return base64ToBase64UrlEncoded(base64);
};
var generateCommitment = function (bytes) {
    var b = bytes || 32;
    return base64ToBase64UrlEncoded(crypto$1.randomBytes(b).toString("base64"));
};
var extractBuffer = function (pemString, type) {
    if (type === "public") {
        var formattedPublicKeyPem = pemString.startsWith(headerPublicKey)
            ? pemString.split(headerPublicKey)[1]
            : pemString;
        formattedPublicKeyPem = formattedPublicKeyPem.endsWith(footerPublicKey)
            ? formattedPublicKeyPem.split(footerPublicKey)[0]
            : formattedPublicKeyPem;
        return Buffer.from(formattedPublicKeyPem.replace(/\r/g, ""), "base64");
    }
    else {
        var formattedPrivateKeyPem = pemString.startsWith(headerPrivateKey)
            ? pemString.split(headerPrivateKey)[1]
            : pemString;
        formattedPrivateKeyPem = formattedPrivateKeyPem.endsWith(footerPrivateKey)
            ? formattedPrivateKeyPem.split(footerPrivateKey)[0]
            : formattedPrivateKeyPem;
        return Buffer.from(formattedPrivateKeyPem.replace(/\r/g, ""), "base64");
    }
};
var pemFormat = function (buffer, type) {
    if (type === "public") {
        var base64 = buffer.toString("base64");
        if (base64.includes("\n")) {
            return "" + headerPublicKey + base64 + footerPublicKey;
        }
        else {
            // @ts-ignore
            var key = base64.match(/.{1,64}/g).join("\n");
            return "" + headerPublicKey + key + footerPublicKey;
        }
    }
    else {
        var base64 = buffer.toString("base64");
        if (base64.includes("\n")) {
            return "" + headerPrivateKey + base64 + footerPrivateKey;
        }
        else {
            // @ts-ignore
            var key = base64.match(/.{1,64}/g).join("\n");
            return "" + headerPrivateKey + key + footerPrivateKey;
        }
    }
};
var bufferToBase64UrlEncoded = function (buffer) {
    var base64 = buffer.toString("base64");
    return base64ToBase64UrlEncoded(base64);
};
var base64ToBase64UrlEncoded = function (base64) {
    return base64.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
};
var base64UrlToBase64Encoded = function (base64Url) {
    return padString(base64Url).replace(/\-/g, "+").replace(/_/g, "/");
};
var base64UrlToBuffer = function (base64Url) {
    var base64 = base64UrlToBase64Encoded(base64Url);
    return Buffer.from(base64, "base64");
};
var sha256ByEachField = function (o) {
    if (isObject(o)) {
        var n_1 = {};
        Object.keys(o).forEach(function (k) {
            if (k === "verified") {
                // Ignore `verified` flag
                // @ts-ignore
                n_1[k] = o[k];
                // @ts-ignore
            }
            else if (o[k] === "" || o[k] === null) {
                // Ignore empty values
                // @ts-ignore
                n_1[k] = o[k];
            }
            else {
                // @ts-ignore
                n_1[k] = sha256ByEachField(o[k]);
            }
        });
        return n_1;
    }
    if (isArray(o)) {
        // @ts-ignore
        return o.map(function (i) { return sha256ByEachField(i); });
    }
    return sha256(o);
};
var padString = function (input) {
    var segmentLength = 4;
    var stringLength = input.length;
    var diff = stringLength % segmentLength;
    if (!diff) {
        return input;
    }
    var position = stringLength;
    var padLength = segmentLength - diff;
    var paddedStringLength = stringLength + padLength;
    var buffer = Buffer.alloc(paddedStringLength);
    buffer.write(input);
    while (padLength--) {
        buffer.write("=", position++);
    }
    return buffer.toString();
};
/**
 * Unify the Json data
 * @param data - can be any type
 * Return the ordered json object
 */
var unifyJsonData = function (unorderedObject) {
    if (!unorderedObject) {
        return unorderedObject;
    }
    if (typeof unorderedObject !== "object") {
        return unorderedObject;
    }
    return Object.keys(unorderedObject)
        .sort()
        .reduce(function (res, key) {
        if (Array.isArray(unorderedObject[key])) {
            // @ts-ignore
            res[key] = unorderedObject[key].map(unifyJsonData);
        }
        else if (typeof unorderedObject[key] === "object") {
            // @ts-ignore
            res[key] = unifyJsonData(unorderedObject[key]);
        }
        else {
            // @ts-ignore
            res[key] = unorderedObject[key];
        }
        return res;
    }, {});
};
var toCamel = function (s) {
    return s.replace(/([-_][a-z])/gi, function ($1) {
        return $1.toUpperCase().replace("-", "").replace("_", "");
    });
};
var toSnake = function (s) {
    var result = s.replace(/([A-Z])/g, " $1");
    return result.split(" ").join("_").toLowerCase();
};
var camelize = function (o) {
    if (isObject(o)) {
        var n_2 = {};
        Object.keys(o).forEach(function (k) {
            // @ts-ignore
            n_2[toCamel(k)] = camelize(o[k]);
        });
        return n_2;
    }
    else if (isArray(o)) {
        return o.map(function (i) {
            return camelize(i);
        });
    }
    return o;
};
var decamelize = function (o) {
    if (isObject(o)) {
        var n_3 = {};
        Object.keys(o).forEach(function (k) {
            // @ts-ignore
            n_3[toSnake(k)] = decamelize(o[k]);
        });
        return n_3;
    }
    else if (isArray(o)) {
        return o.map(function (i) {
            return decamelize(i);
        });
    }
    return o;
};

var DEFAULT_KEY_SIZE = 3072;
var Encryption = /** @class */ (function () {
    function Encryption() {
        var checkIsBrowser = new Function("try {return this===window;}catch(e){ return false;}");
        var isBrowser = checkIsBrowser();
        if (isBrowser) {
            this._crypto = crypto;
        }
        else {
            this._crypto = new webcrypto.Crypto();
        }
    }
    Object.defineProperty(Encryption.prototype, "privateKey", {
        get: function () {
            return this._privateKey;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Encryption.prototype, "publicKey", {
        get: function () {
            return this._publicKey;
        },
        enumerable: false,
        configurable: true
    });
    Encryption.prototype.generateKeyPair = function (keySize) {
        if (keySize === void 0) { keySize = DEFAULT_KEY_SIZE; }
        return __awaiter(this, void 0, void 0, function () {
            var keys;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this._crypto.subtle.generateKey({
                            name: "RSA-OAEP",
                            hash: "SHA-256",
                            publicExponent: new Uint8Array([1, 0, 1]),
                            modulusLength: keySize,
                        }, true, ["encrypt", "decrypt"])];
                    case 1:
                        keys = _a.sent();
                        this._privateKey = keys.privateKey;
                        this._publicKey = keys.publicKey;
                        return [2 /*return*/];
                }
            });
        });
    };
    Encryption.prototype.importPrivateKey = function (pem, password) {
        return __awaiter(this, void 0, void 0, function () {
            var rawPem, decomposedKey, buffer, key;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        rawPem = pem;
                        if (password) {
                            decomposedKey = cryptoKeyComposer.decomposePrivateKey("\n" + pem + "\n", {
                                password: password,
                                format: "pkcs8-pem",
                            });
                            // Remove unnecessary property
                            delete decomposedKey["encryptionAlgorithm"];
                            rawPem = cryptoKeyComposer.composePrivateKey(decomposedKey).replace(/\n$/, "");
                        }
                        buffer = extractBuffer(rawPem, "private");
                        return [4 /*yield*/, this._crypto.subtle.importKey("pkcs8", buffer, {
                                name: "RSA-OAEP",
                                hash: "SHA-256",
                            }, true, ["decrypt"])];
                    case 1:
                        key = _a.sent();
                        this._privateKey = key;
                        return [2 /*return*/];
                }
            });
        });
    };
    Encryption.prototype.importPrivateKeyInBase64Url = function (pem, password) {
        return __awaiter(this, void 0, void 0, function () {
            var rawPem, buffer, key;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        rawPem = base64UrlToBase64Encoded(pem);
                        rawPem = pemFormat(Buffer.from(rawPem, "base64"), "private");
                        if (password) {
                            throw new Error("Password decryption is not supported yet.");
                            // const decomposedKey = decomposePrivateKey(`\n${pem}\n`, { password, format: "pkcs8-pem" });
                            // Remove unnecessary property
                            // delete decomposedKey["encryptionAlgorithm"];
                            // rawPem = composePrivateKey(decomposedKey);
                        }
                        buffer = extractBuffer(rawPem, "private");
                        return [4 /*yield*/, this._crypto.subtle.importKey("pkcs8", buffer, {
                                name: "RSA-OAEP",
                                hash: "SHA-256",
                            }, true, ["decrypt"])];
                    case 1:
                        key = _a.sent();
                        this._privateKey = key;
                        return [2 /*return*/];
                }
            });
        });
    };
    Encryption.prototype.importPublicKey = function (pem) {
        return __awaiter(this, void 0, void 0, function () {
            var buffer, key;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        buffer = extractBuffer(pem, "public");
                        return [4 /*yield*/, this._crypto.subtle.importKey("spki", buffer, {
                                name: "RSA-OAEP",
                                hash: "SHA-256",
                            }, true, ["encrypt"])];
                    case 1:
                        key = _a.sent();
                        this._publicKey = key;
                        return [2 /*return*/];
                }
            });
        });
    };
    Encryption.prototype.importPublicKeyInBase64Url = function (pem) {
        return __awaiter(this, void 0, void 0, function () {
            var base64, buffer, key;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        base64 = base64UrlToBase64Encoded(pem);
                        buffer = Buffer.from(base64, "base64");
                        return [4 /*yield*/, this._crypto.subtle.importKey("spki", buffer, {
                                name: "RSA-OAEP",
                                hash: "SHA-256",
                            }, true, ["encrypt"])];
                    case 1:
                        key = _a.sent();
                        this._publicKey = key;
                        return [2 /*return*/];
                }
            });
        });
    };
    Encryption.prototype.encrypt = function (data) {
        return __awaiter(this, void 0, void 0, function () {
            var enc;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!this._publicKey) {
                            throw new Error("public key is not passed properly.");
                        }
                        return [4 /*yield*/, this._crypto.subtle.encrypt("RSA-OAEP", this._publicKey, data)];
                    case 1:
                        enc = _a.sent();
                        return [2 /*return*/, Buffer.from(new Uint8Array(enc))];
                }
            });
        });
    };
    Encryption.prototype.encryptStringToBase64UrlString = function (message) {
        return __awaiter(this, void 0, void 0, function () {
            var enc;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!this._publicKey) {
                            throw new Error("public key is not passed properly.");
                        }
                        return [4 /*yield*/, this.rsaLargeMessageEncrypt(message)];
                    case 1:
                        enc = _a.sent();
                        return [2 /*return*/, bufferToBase64UrlEncoded(enc)];
                }
            });
        });
    };
    Encryption.prototype.encryptFieldByField = function (plain) {
        return __awaiter(this, void 0, void 0, function () {
            var n, keys, _i, keys_1, k, _a, _b, n, _c, plain_1, i, d;
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        if (!isObject(plain)) return [3 /*break*/, 5];
                        n = {};
                        keys = Object.keys(plain);
                        _i = 0, keys_1 = keys;
                        _d.label = 1;
                    case 1:
                        if (!(_i < keys_1.length)) return [3 /*break*/, 4];
                        k = keys_1[_i];
                        // @ts-ignore
                        _a = n;
                        _b = k;
                        return [4 /*yield*/, this.encryptFieldByField(plain[k])];
                    case 2:
                        // @ts-ignore
                        _a[_b] = _d.sent();
                        _d.label = 3;
                    case 3:
                        _i++;
                        return [3 /*break*/, 1];
                    case 4: return [2 /*return*/, n];
                    case 5:
                        if (!isArray(plain)) return [3 /*break*/, 10];
                        n = [];
                        _c = 0, plain_1 = plain;
                        _d.label = 6;
                    case 6:
                        if (!(_c < plain_1.length)) return [3 /*break*/, 9];
                        i = plain_1[_c];
                        return [4 /*yield*/, this.encryptFieldByField(i)];
                    case 7:
                        d = _d.sent();
                        n.push(d);
                        _d.label = 8;
                    case 8:
                        _c++;
                        return [3 /*break*/, 6];
                    case 9: return [2 /*return*/, n];
                    case 10:
                        if (plain === null) {
                            return [2 /*return*/, null];
                        }
                        if (plain === "") {
                            return [2 /*return*/, ""];
                        }
                        if (plain === true) {
                            return [2 /*return*/, true];
                        }
                        if (plain === false) {
                            return [2 /*return*/, false];
                        }
                        return [4 /*yield*/, this.encryptStringToBase64UrlString(plain)];
                    case 11: return [2 /*return*/, _d.sent()];
                }
            });
        });
    };
    Encryption.prototype.decrypt = function (cipher) {
        return __awaiter(this, void 0, void 0, function () {
            var dec;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!this._privateKey) {
                            throw new Error("private key is not passed properly.");
                        }
                        return [4 /*yield*/, this._crypto.subtle.decrypt("RSA-OAEP", this._privateKey, cipher)];
                    case 1:
                        dec = _a.sent();
                        return [2 /*return*/, Buffer.from(dec).toString("utf8")];
                }
            });
        });
    };
    Encryption.prototype.decryptBase64UrlStringToString = function (cipher) {
        return __awaiter(this, void 0, void 0, function () {
            var base64;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        base64 = base64UrlToBase64Encoded(cipher);
                        return [4 /*yield*/, this.rsaLargeMessageDecrypt(Buffer.from(base64, "base64"))];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    Encryption.prototype.decryptFieldByField = function (cipher) {
        return __awaiter(this, void 0, void 0, function () {
            var n, keys, _i, keys_2, k, _a, _b, n, _c, cipher_1, i, d;
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        if (!isObject(cipher)) return [3 /*break*/, 5];
                        n = {};
                        keys = Object.keys(cipher);
                        _i = 0, keys_2 = keys;
                        _d.label = 1;
                    case 1:
                        if (!(_i < keys_2.length)) return [3 /*break*/, 4];
                        k = keys_2[_i];
                        // @ts-ignore
                        _a = n;
                        _b = k;
                        return [4 /*yield*/, this.decryptFieldByField(cipher[k])];
                    case 2:
                        // @ts-ignore
                        _a[_b] = _d.sent();
                        _d.label = 3;
                    case 3:
                        _i++;
                        return [3 /*break*/, 1];
                    case 4: return [2 /*return*/, n];
                    case 5:
                        if (!isArray(cipher)) return [3 /*break*/, 10];
                        n = [];
                        _c = 0, cipher_1 = cipher;
                        _d.label = 6;
                    case 6:
                        if (!(_c < cipher_1.length)) return [3 /*break*/, 9];
                        i = cipher_1[_c];
                        return [4 /*yield*/, this.decryptFieldByField(i)];
                    case 7:
                        d = _d.sent();
                        n.push(d);
                        _d.label = 8;
                    case 8:
                        _c++;
                        return [3 /*break*/, 6];
                    case 9: return [2 /*return*/, n];
                    case 10:
                        if (cipher === null) {
                            return [2 /*return*/, null];
                        }
                        if (cipher === "") {
                            return [2 /*return*/, ""];
                        }
                        if (cipher === true) {
                            return [2 /*return*/, true];
                        }
                        if (cipher === false) {
                            return [2 /*return*/, false];
                        }
                        return [4 /*yield*/, this.decryptBase64UrlStringToString(cipher)];
                    case 11: return [2 /*return*/, _d.sent()];
                }
            });
        });
    };
    Encryption.prototype.exportPrivateKey = function (password) {
        return __awaiter(this, void 0, void 0, function () {
            var data, rawPem, decomposedKey;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!this._privateKey) {
                            throw new Error("private key is not instantiated.");
                        }
                        return [4 /*yield*/, this._crypto.subtle.exportKey("pkcs8", this._privateKey)];
                    case 1:
                        data = _a.sent();
                        rawPem = pemFormat(Buffer.from(data), "private");
                        if (!password) {
                            return [2 /*return*/, rawPem];
                        }
                        decomposedKey = cryptoKeyComposer.decomposePrivateKey("\n" + rawPem + "\n", {
                            format: "pkcs8-pem",
                        });
                        // @ts-ignore
                        decomposedKey["encryptionAlgorithm"] = {
                            keyDerivationFunc: {
                                id: "pbkdf2",
                                iterationCount: 10000,
                                keyLength: 32,
                                prf: "hmac-with-sha256",
                            },
                            encryptionScheme: "aes256-cbc",
                        };
                        return [2 /*return*/, cryptoKeyComposer.composePrivateKey(decomposedKey, { password: password }).replace(/\n$/, "")];
                }
            });
        });
    };
    Encryption.prototype.exportPrivateKeyInBase64Url = function () {
        return __awaiter(this, void 0, void 0, function () {
            var privateKey, buffer;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.exportPrivateKey()];
                    case 1:
                        privateKey = _a.sent();
                        buffer = extractBuffer(privateKey, "private");
                        return [2 /*return*/, bufferToBase64UrlEncoded(buffer)];
                }
            });
        });
    };
    Encryption.prototype.exportPublicKey = function () {
        return __awaiter(this, void 0, void 0, function () {
            var data;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!this._publicKey) {
                            throw new Error("public key is not instantiated.");
                        }
                        return [4 /*yield*/, this._crypto.subtle.exportKey("spki", this._publicKey)];
                    case 1:
                        data = _a.sent();
                        return [2 /*return*/, pemFormat(Buffer.from(data), "public")];
                }
            });
        });
    };
    Encryption.prototype.exportPublicKeyInBase64Url = function () {
        return __awaiter(this, void 0, void 0, function () {
            var publicKey, buffer;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.exportPublicKey()];
                    case 1:
                        publicKey = _a.sent();
                        buffer = extractBuffer(publicKey, "public");
                        return [2 /*return*/, bufferToBase64UrlEncoded(buffer)];
                }
            });
        });
    };
    Encryption.prototype.rsaLargeMessageEncrypt = function (msg) {
        return __awaiter(this, void 0, void 0, function () {
            var bufferData, keySize, hashSize, blockSize, length, numBlocks, res, i, currentSize, block, bufferEncData, j;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!this.publicKey) {
                            throw new Error("public key is not passed properly.");
                        }
                        bufferData = Buffer.from(msg, "utf-8");
                        keySize = this.publicKey.algorithm.modulusLength / 8;
                        hashSize = 32;
                        blockSize = keySize - 2 * hashSize - 2;
                        length = bufferData.length;
                        numBlocks = Math.floor(length / blockSize);
                        if (length % blockSize !== 0) {
                            numBlocks += 1;
                        }
                        res = Buffer.alloc(keySize * numBlocks);
                        i = 0;
                        _a.label = 1;
                    case 1:
                        if (!(i < numBlocks)) return [3 /*break*/, 4];
                        currentSize = blockSize;
                        if (bufferData.length < (i + 1) * blockSize) {
                            currentSize = bufferData.length - i * blockSize;
                        }
                        block = bufferData.slice(i * blockSize, i * blockSize + currentSize);
                        return [4 /*yield*/, this.encrypt(block)];
                    case 2:
                        bufferEncData = _a.sent();
                        for (j = i * keySize; j < i * keySize + bufferEncData.length; j++) {
                            res[j] = bufferEncData[j - i * keySize];
                        }
                        _a.label = 3;
                    case 3:
                        i++;
                        return [3 /*break*/, 1];
                    case 4: return [2 /*return*/, res];
                }
            });
        });
    };
    Encryption.prototype.rsaLargeMessageDecrypt = function (cipher) {
        return __awaiter(this, void 0, void 0, function () {
            var keySize, length, numBlocks, res, i, block, pt;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!this.privateKey) {
                            throw new Error("private key is not passed properly.");
                        }
                        keySize = this.privateKey.algorithm.modulusLength / 8;
                        length = cipher.length;
                        if (length % keySize !== 0) {
                            throw new Error("invalid key size");
                        }
                        numBlocks = length / keySize;
                        res = "";
                        i = 0;
                        _a.label = 1;
                    case 1:
                        if (!(i < numBlocks)) return [3 /*break*/, 4];
                        block = cipher.slice(i * keySize, (i + 1) * keySize);
                        return [4 /*yield*/, this.decrypt(block)];
                    case 2:
                        pt = _a.sent();
                        res += pt;
                        _a.label = 3;
                    case 3:
                        i++;
                        return [3 /*break*/, 1];
                    case 4: return [2 /*return*/, res];
                }
            });
        });
    };
    return Encryption;
}());

var Signing = /** @class */ (function () {
    function Signing() {
    }
    Object.defineProperty(Signing.prototype, "privateKey", {
        get: function () {
            return Buffer.from(this._privateKey);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Signing.prototype, "publicKey", {
        get: function () {
            return Buffer.from(this._publicKey);
        },
        enumerable: false,
        configurable: true
    });
    Signing.prototype.generateKeyPair = function () {
        var keyPair = nodeForge.pki.ed25519.generateKeyPair();
        this._privateKey = keyPair.privateKey;
        this._publicKey = keyPair.publicKey;
    };
    Signing.prototype.importSeed = function (seed) {
        var bytes = base64UrlToBuffer(seed);
        var keyPair = nodeForge.pki.ed25519.generateKeyPair({ seed: bytes });
        this._privateKey = keyPair.privateKey;
        this._publicKey = keyPair.publicKey;
    };
    Signing.prototype.importPrivateKey = function (pem, password) {
        var decomposedKey = cryptoKeyComposer.decomposePrivateKey("\n" + pem + "\n", { password: password, format: "pkcs8-pem" });
        var seed = decomposedKey.keyData.seed;
        var keyPair = nodeForge.pki.ed25519.generateKeyPair({ seed: seed });
        this._privateKey = keyPair.privateKey;
        this._publicKey = keyPair.publicKey;
    };
    Signing.prototype.importPrivateKeyInBase64Url = function (pem, password) {
        var pemData = base64UrlToBase64Encoded(pem);
        var p = pemFormat(Buffer.from(pemData, "base64"), "private");
        var decomposedKey = cryptoKeyComposer.decomposePrivateKey("\n" + p + "\n", { password: password, format: "pkcs8-pem" });
        var seed = decomposedKey.keyData.seed;
        var keyPair = nodeForge.pki.ed25519.generateKeyPair({ seed: seed });
        this._privateKey = keyPair.privateKey;
        this._publicKey = keyPair.publicKey;
    };
    Signing.prototype.importPublicKey = function (pem) {
        var decomposedKey = cryptoKeyComposer.decomposePublicKey("\n" + pem + "\n");
        this._publicKey = decomposedKey.keyData.bytes;
    };
    Signing.prototype.importPublicKeyInBase64Url = function (pem) {
        var pemData = base64UrlToBase64Encoded(pem);
        var p = pemFormat(Buffer.from(pemData, "base64"), "public");
        var decomposedKey = cryptoKeyComposer.decomposePublicKey("\n" + p + "\n");
        this._publicKey = decomposedKey.keyData.bytes;
    };
    Signing.prototype.sign = function (message, option) {
        if (!this._privateKey)
            throw new Error("Private key is not set yet.");
        var decoded = base64UrlToBuffer(message);
        if ((option === null || option === void 0 ? void 0 : option.input) === "base64") {
            decoded = Buffer.from(message, "base64");
        }
        if ((option === null || option === void 0 ? void 0 : option.input) === "utf8") {
            decoded = Buffer.from(message);
        }
        if ((option === null || option === void 0 ? void 0 : option.input) === "hex") {
            decoded = Buffer.from(message, "hex");
        }
        var base64 = nodeForge.pki.ed25519.sign({ message: decoded, encoding: "binary", privateKey: this._privateKey }).toString("base64");
        if (base64.includes(",")) {
            // FIXME: Next.js was not working well with pki.ed25519.sign's format
            base64 = Buffer.from(base64.split(",").map(Number)).toString("base64");
        }
        if ((option === null || option === void 0 ? void 0 : option.output) === "base64") {
            return base64;
        }
        if ((option === null || option === void 0 ? void 0 : option.output) === "utf8") {
            return Buffer.from(base64, "base64").toString("utf8");
        }
        if ((option === null || option === void 0 ? void 0 : option.output) === "hex") {
            return Buffer.from(base64, "base64").toString("hex");
        }
        // Default is base64URL encoded string
        return base64ToBase64UrlEncoded(base64);
    };
    Signing.prototype.verify = function (message, signature, option) {
        if (!this._publicKey)
            throw new Error("Public key is not set yet.");
        var sig = "";
        if ((option === null || option === void 0 ? void 0 : option.encode) === "base64") {
            sig = signature;
        }
        else {
            // Default is base64URL encoded string
            sig = base64UrlToBase64Encoded(signature);
        }
        return nodeForge.pki.ed25519.verify({
            message: message,
            encoding: "binary",
            signature: Buffer.from(sig, "base64"),
            publicKey: this._publicKey
        });
    };
    Signing.prototype.exportPrivateKey = function (password) {
        if (!this._privateKey) {
            throw new Error("private key is not instantiated.");
        }
        var decomposed = {
            format: 'pkcs8-pem',
            keyAlgorithm: { id: 'ed25519' },
            keyData: {
                seed: this._privateKey.slice(0, 32),
            },
        };
        if (password) {
            // @ts-ignore
            decomposed["encryptionAlgorithm"] = {
                keyDerivationFunc: {
                    id: 'pbkdf2',
                    iterationCount: 10000,
                    keyLength: 32,
                    prf: 'hmac-with-sha256' // The pseudo-random function
                },
                encryptionScheme: 'aes256-cbc',
            };
        }
        return cryptoKeyComposer.composePrivateKey(decomposed, { password: password }).replace(/\n$/, "");
    };
    Signing.prototype.exportPublicKey = function () {
        if (!this._publicKey) {
            throw new Error("public key is not instantiated.");
        }
        var decomposed = {
            format: 'spki-pem',
            keyAlgorithm: { id: 'ed25519' },
            keyData: {
                bytes: this._publicKey,
            },
        };
        return cryptoKeyComposer.composePublicKey(decomposed).replace(/\n$/, "");
    };
    Signing.prototype.exportPrivateKeyInBase64Url = function () {
        var privPem = this.exportPrivateKey();
        var buffer = extractBuffer(privPem, "private");
        return bufferToBase64UrlEncoded(buffer);
    };
    Signing.prototype.exportPublicKeyInBase64Url = function () {
        var pubPem = this.exportPublicKey();
        var pubBuffer = extractBuffer(pubPem, "public");
        return bufferToBase64UrlEncoded(pubBuffer);
    };
    Signing.prototype.exportSeed = function () {
        var seedData = this._privateKey.slice(0, 32);
        // @ts-ignore
        return bufferToBase64UrlEncoded(seedData);
    };
    return Signing;
}());

var decodeTokenComponent = function (base64Url) {
    var base64 = base64UrlToBase64Encoded(base64Url);
    return JSON.parse(Buffer.from(base64, "base64").toString("binary"));
};
var encodeTokenComponent = function (json) {
    var base64Encoded = Buffer.from(JSON.stringify(json)).toString("base64");
    return base64ToBase64UrlEncoded(base64Encoded);
};
var composeMessage = function (header, payload) {
    return encodeTokenComponent(header) + "." + encodeTokenComponent(payload);
};
var parseJwt = function (token) {
    var _a = token.split("."), headerEncoded = _a[0], payloadEncoded = _a[1], signature = _a[2];
    var _b = [headerEncoded, payloadEncoded].map(decodeTokenComponent), header = _b[0], payload = _b[1];
    // @ts-ignore
    if (!header["alg"] || !header["typ"]) {
        throw new Error("Header format is not correct.");
    }
    // @ts-ignore
    return { header: header, headerEncoded: headerEncoded, payload: payload, payloadEncoded: payloadEncoded, signature: signature };
};
/**
 * Generates a JWT.
 * @param signing
 * @param payload
 */
var generateJwt = function (signing, payload) {
    // NOTE: Added `- 60` just in case a timestamp in the BE is not working properly.
    var timestamp = Number((new Date().getTime() / 1000).toFixed(0)) - 60;
    var header = {
        alg: "EdDSA",
        typ: "JWT",
    };
    var p = payload || {
        exp: timestamp + 60 * 60,
        iat: timestamp,
        signing_key: signing.exportPublicKey(),
    };
    var signature = signing.sign(composeMessage(header, p), { input: "utf8" });
    return encodeTokenComponent(header) + "." + encodeTokenComponent(p) + "." + signature;
};
/**
 * Generates an approval token
 * @param signing
 * @param clientId
 * @param entityId
 * @param approvedScopes
 * @param offerCode
 */
var generateApprovalToken = function (signing, clientId, entityId, approvedScopes, offerCode) {
    // NOTE: Added `- 60` just in case a timestamp in the BE is not working properly.
    var timestamp = Number((new Date().getTime() / 1000).toFixed(0)) - 60;
    var payload = {
        client_id: clientId,
        iat: timestamp,
        iss: entityId,
        scopes: approvedScopes.join(" "),
    };
    if (offerCode) {
        // @ts-ignore
        payload["offer_code"] = offerCode;
    }
    return generateJwt(signing, payload);
};
/**
 * Generates a claim token and a commitment
 * @param signing
 * @param providerId
 * @param entityId
 * @param scopeName
 * @param claim - claim object with raw values.
 * @returns { token: string; commitment: string }
 */
var generateClaimToken = function (signing, providerId, entityId, scopeName, claim) {
    var _a;
    // NOTE: Added `- 60` just in case a timestamp in the BE is not working properly.
    var timestamp = Number((new Date().getTime() / 1000).toFixed(0)) - 60;
    var commitment = generateCommitment();
    var key = scopeName.includes(":")
        ? scopeName + ":commitment"
        : scopeName + "_commitment";
    var scopeHash = sha256(unifyJsonData(_assign(_assign({}, claim), (_a = {}, _a[key] = commitment, _a))));
    var payload = {
        iat: timestamp,
        iss: providerId,
        user_id: entityId,
        scope_name: scopeName,
        scope_hash: scopeHash,
    };
    var token = generateJwt(signing, payload);
    return { token: token, commitment: commitment };
};
/**
 * Generate disbursement token
 * @param signing
 * @param providerId
 * @param entityId
 * @param claimObj
 *  format: { claims[keyA]: { [disbursement_key]: {}, [commitment_key]: {} }, claims[keyB] ... }
 * @param publicKey
 * @returns string
 */
var generateDisbursementToken = function (signing, providerId, entityId, claimObj, publicKey) { return __awaiter(void 0, void 0, void 0, function () {
    var disbursementClaimComposeObj, encryptedContents, timestamp, enc_1, payload, token;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                disbursementClaimComposeObj = {};
                timestamp = Number((new Date().getTime() / 1000).toFixed(0)) - 60;
                if (!publicKey) return [3 /*break*/, 6];
                enc_1 = new Encryption();
                if (!publicKey.startsWith("M")) return [3 /*break*/, 2];
                return [4 /*yield*/, enc_1.importPublicKeyInBase64Url(publicKey)];
            case 1:
                _a.sent();
                return [3 /*break*/, 4];
            case 2: return [4 /*yield*/, enc_1.importPublicKey(publicKey)];
            case 3:
                _a.sent();
                _a.label = 4;
            case 4: return [4 /*yield*/, Promise.all(Object.keys(claimObj).map(function (scopeKey) {
                    if (!claimObj[scopeKey][scopeKey]) {
                        throw new Error("Disbursement claim object is not valid");
                    }
                    return enc_1.encryptStringToBase64UrlString(claimObj[scopeKey][scopeKey].content);
                }))];
            case 5:
                encryptedContents = _a.sent();
                _a.label = 6;
            case 6:
                // Transform claim obj
                Object.keys(claimObj).forEach(function (scopeKey, index) {
                    var claim = claimObj[scopeKey];
                    if (!claim[scopeKey]) {
                        throw new Error("Disbursement claim object is not valid");
                    }
                    var content = publicKey
                        ? encryptedContents[index]
                        : claim[scopeKey].content;
                    disbursementClaimComposeObj[scopeKey] = {
                        content_type: claim[scopeKey].content_type,
                        content: content,
                    };
                    disbursementClaimComposeObj[scopeKey + ":commitment"] =
                        claim[scopeKey + ":commitment"];
                });
                payload = _assign({ iat: timestamp, iss: providerId, user_id: entityId }, disbursementClaimComposeObj);
                token = generateJwt(signing, payload);
                return [2 /*return*/, token];
        }
    });
}); };
/**
 * Generates a request token
 * @param signing
 * @param encryptionPublicKey - Base64 URL encoded public key
 * @param scopes - Requested scopes list.
 * @param offerCode
 */
var generateRequestToken = function (signing, encryptionPublicKey, scopes, offerCode) {
    if (!scopes.includes("openid")) {
        throw new Error("openid is required.");
    }
    // NOTE: Added `- 60` just in case a timestamp in the BE is not working properly.
    var timestamp = Number((new Date().getTime() / 1000).toFixed(0)) - 60;
    var formattedScopes = scopes.join(" ");
    var payload = {
        encryption_public_key: encryptionPublicKey,
        iat: timestamp,
        scopes: formattedScopes,
    };
    if (offerCode) {
        // @ts-ignore
        payload["offer_code"] = offerCode;
    }
    return generateJwt(signing, payload);
};
/**
 * Generates an identity token
 * @param signing
 * @param entityId
 * @param identitySource
 * @param identityHash
 */
var generateIdentityToken = function (signing, entityId, identitySource, identityHash) {
    // NOTE: Added `- 60` just in case a timestamp in the BE is not working properly.
    var timestamp = Number((new Date().getTime() / 1000).toFixed(0)) - 60;
    var payload = {
        iat: timestamp,
        iss: entityId,
        identity_source: identitySource,
        identity_hash: identityHash,
    };
    return generateJwt(signing, payload);
};
var verifyJwt = function (jwt, signing) {
    var message = jwt.headerEncoded + "." + jwt.payloadEncoded;
    return signing.verify(message, jwt.signature);
};

// @ts-ignore
var ripemd160 = require("eosjs/dist/ripemd").RIPEMD160.hash;
var ecdsa = new elliptic.ec("secp256k1");
var Wallet = /** @class */ (function () {
    function Wallet(mnemonic) {
        if (mnemonic.split(" ").length !== 12) {
            throw new Error("Mnemonic format is not correct");
        }
        this.mnemonic = mnemonic;
        var seed = bip39.mnemonicToSeedSync(this.mnemonic);
        this.masterNode = HDKey.fromMasterSeed(seed);
    }
    Wallet.create = function () {
        var m = bip39.generateMnemonic();
        return new Wallet(m);
    };
    Wallet.prototype.getMnemonic = function () {
        return this.mnemonic;
    };
    Wallet.prototype.getMasterPrivateKey = function () {
        var masterPrivateKey = wif.encode(128, this.masterNode.privateKey, true);
        // console.log(`==> getMasterPrivateKey : ${masterPrivateKey}`);
        return masterPrivateKey;
    };
    Wallet.prototype.getMasterPublicKey = function () {
        var masterPublicKey = this.masterNode.publicKey.toString("hex");
        // console.log(`==> getMasterPublicKey : ${masterPublicKey}`);
        return masterPublicKey;
    };
    Wallet.prototype.getEOSPrivateKey = function () {
        var childNode = this.masterNode.derive(this.getCoinKey("EOS"));
        var ellipticKeyPair = ecdsa.keyFromPrivate(childNode.privateKey);
        var eosPrivateKey = eosjsJssig.PrivateKey.fromElliptic(ellipticKeyPair, eosjsNumeric.KeyType.k1, ecdsa);
        return eosPrivateKey.toLegacyString();
    };
    Wallet.prototype.getEOSPublicKey = function () {
        var childNode = this.masterNode.derive(this.getCoinKey("EOS"));
        var ellipticKeyPair = ecdsa.keyFromPrivate(childNode.privateKey);
        var eosPublicKey = eosjsJssig.PublicKey.fromElliptic(ellipticKeyPair, eosjsNumeric.KeyType.k1, ecdsa);
        return this.convertToEosLegacyPublicKey(eosPublicKey);
    };
    Wallet.prototype.getCoinKey = function (coinType) {
        switch (coinType) {
            case "BTC": {
                return "";
            }
            case "EOS": {
                return 'm/44\'/194\'/0\'/0/0';
            }
            case "ETH": {
                return 'm/44\'/60\'/1\'/0/0';
            }
            case "XRP": {
                return "";
            }
        }
    };
    Wallet.prototype.convertToEosLegacyPublicKey = function (publicKey) {
        var keyString = publicKey.toString();
        var key = eosjsNumeric.stringToPublicKey(keyString);
        if (key.type == eosjsNumeric.KeyType.k1 && key.data.length === eosjsNumeric.publicKeyDataSize) {
            var digest = new Uint8Array(ripemd160(key.data));
            var whole = new Uint8Array(eosjsNumeric.publicKeyDataSize + 4);
            for (var i = 0; i < eosjsNumeric.publicKeyDataSize; ++i)
                whole[i] = key.data[i];
            for (var i = 0; i < 4; ++i)
                whole[i + eosjsNumeric.publicKeyDataSize] = digest[i];
            return "EOS" + eosjsNumeric.binaryToBase58(whole);
        }
        else if (key.type == eosjsNumeric.KeyType.r1 && key.data.length === eosjsNumeric.publicKeyDataSize) {
            return keyString;
        }
        else {
            throw new Error("unrecognized public key format");
        }
    };
    return Wallet;
}());

var index = {
    Encryption: Encryption,
    Signing: Signing,
    generateJwt: generateJwt,
    parseJwt: parseJwt,
    verifyJwt: verifyJwt,
    generateRequestToken: generateRequestToken,
    generateApprovalToken: generateApprovalToken,
    generateIdentityToken: generateIdentityToken,
    generateClaimToken: generateClaimToken,
    generateDisbursementToken: generateDisbursementToken,
    sha256: sha256,
    generateCommitment: generateCommitment,
    base64UrlToBuffer: base64UrlToBuffer,
    base64ToBase64UrlEncoded: base64ToBase64UrlEncoded,
    base64UrlToBase64Encoded: base64UrlToBase64Encoded,
    bufferToBase64UrlEncoded: bufferToBase64UrlEncoded,
    sha256ByEachField: sha256ByEachField,
    camelize: camelize,
    decamelize: decamelize,
    unifyJsonData: unifyJsonData,
    Wallet: Wallet,
};

module.exports = index;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VzIjpbIi4uL25vZGVfbW9kdWxlcy90c2xpYi90c2xpYi5lczYuanMiLCIuLi9zcmMvdXRpbHMudHMiLCIuLi9zcmMvZW5jcnlwdGlvbi50cyIsIi4uL3NyYy9zaWduaW5nLnRzIiwiLi4vc3JjL2p3dC50cyIsIi4uL3NyYy93YWxsZXQudHMiLCIuLi9zcmMvaW5kZXgudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cclxuXHJcblBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxyXG5wdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXHJcblxyXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXHJcblJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxyXG5BTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXHJcbklORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxyXG5MT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxyXG5PVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXHJcblBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcbi8qIGdsb2JhbCBSZWZsZWN0LCBQcm9taXNlICovXHJcblxyXG52YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uKGQsIGIpIHtcclxuICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcclxuICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG59O1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZXh0ZW5kcyhkLCBiKSB7XHJcbiAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxyXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcclxuICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxufVxyXG5cclxuZXhwb3J0IHZhciBfX2Fzc2lnbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uIF9fYXNzaWduKHQpIHtcclxuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKSB0W3BdID0gc1twXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHQ7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fcmVzdChzLCBlKSB7XHJcbiAgICB2YXIgdCA9IHt9O1xyXG4gICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApXHJcbiAgICAgICAgdFtwXSA9IHNbcF07XHJcbiAgICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoZS5pbmRleE9mKHBbaV0pIDwgMCAmJiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocywgcFtpXSkpXHJcbiAgICAgICAgICAgICAgICB0W3BbaV1dID0gc1twW2ldXTtcclxuICAgICAgICB9XHJcbiAgICByZXR1cm4gdDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcclxuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xyXG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcclxuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3BhcmFtKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIGtleSkgeyBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIHBhcmFtSW5kZXgpOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX21ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hd2FpdGVyKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xyXG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XHJcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cclxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XHJcbiAgICB9KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZ2VuZXJhdG9yKHRoaXNBcmcsIGJvZHkpIHtcclxuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XHJcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xyXG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcclxuICAgICAgICB3aGlsZSAoXykgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xyXG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XHJcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxyXG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgdmFyIF9fY3JlYXRlQmluZGluZyA9IE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcclxuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XHJcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XHJcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xyXG4gICAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xyXG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xyXG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcclxuICAgIG9bazJdID0gbVtrXTtcclxufSk7XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19leHBvcnRTdGFyKG0sIG8pIHtcclxuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobywgcCkpIF9fY3JlYXRlQmluZGluZyhvLCBtLCBwKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fdmFsdWVzKG8pIHtcclxuICAgIHZhciBzID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5pdGVyYXRvciwgbSA9IHMgJiYgb1tzXSwgaSA9IDA7XHJcbiAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcclxuICAgIGlmIChvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgcmV0dXJuIHtcclxuICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XHJcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baSsrXSwgZG9uZTogIW8gfTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihzID8gXCJPYmplY3QgaXMgbm90IGl0ZXJhYmxlLlwiIDogXCJTeW1ib2wuaXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19yZWFkKG8sIG4pIHtcclxuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcclxuICAgIGlmICghbSkgcmV0dXJuIG87XHJcbiAgICB2YXIgaSA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZXJyb3IpIHsgZSA9IHsgZXJyb3I6IGVycm9yIH07IH1cclxuICAgIGZpbmFsbHkge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmaW5hbGx5IHsgaWYgKGUpIHRocm93IGUuZXJyb3I7IH1cclxuICAgIH1cclxuICAgIHJldHVybiBhcjtcclxufVxyXG5cclxuLyoqIEBkZXByZWNhdGVkICovXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3NwcmVhZCgpIHtcclxuICAgIGZvciAodmFyIGFyID0gW10sIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIGFyID0gYXIuY29uY2F0KF9fcmVhZChhcmd1bWVudHNbaV0pKTtcclxuICAgIHJldHVybiBhcjtcclxufVxyXG5cclxuLyoqIEBkZXByZWNhdGVkICovXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3NwcmVhZEFycmF5cygpIHtcclxuICAgIGZvciAodmFyIHMgPSAwLCBpID0gMCwgaWwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgaWw7IGkrKykgcyArPSBhcmd1bWVudHNbaV0ubGVuZ3RoO1xyXG4gICAgZm9yICh2YXIgciA9IEFycmF5KHMpLCBrID0gMCwgaSA9IDA7IGkgPCBpbDsgaSsrKVxyXG4gICAgICAgIGZvciAodmFyIGEgPSBhcmd1bWVudHNbaV0sIGogPSAwLCBqbCA9IGEubGVuZ3RoOyBqIDwgamw7IGorKywgaysrKVxyXG4gICAgICAgICAgICByW2tdID0gYVtqXTtcclxuICAgIHJldHVybiByO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19zcHJlYWRBcnJheSh0bywgZnJvbSwgcGFjaykge1xyXG4gICAgaWYgKHBhY2sgfHwgYXJndW1lbnRzLmxlbmd0aCA9PT0gMikgZm9yICh2YXIgaSA9IDAsIGwgPSBmcm9tLmxlbmd0aCwgYXI7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICBpZiAoYXIgfHwgIShpIGluIGZyb20pKSB7XHJcbiAgICAgICAgICAgIGlmICghYXIpIGFyID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSwgMCwgaSk7XHJcbiAgICAgICAgICAgIGFyW2ldID0gZnJvbVtpXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdG8uY29uY2F0KGFyIHx8IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20pKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXdhaXQodikge1xyXG4gICAgcmV0dXJuIHRoaXMgaW5zdGFuY2VvZiBfX2F3YWl0ID8gKHRoaXMudiA9IHYsIHRoaXMpIDogbmV3IF9fYXdhaXQodik7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2FzeW5jR2VuZXJhdG9yKHRoaXNBcmcsIF9hcmd1bWVudHMsIGdlbmVyYXRvcikge1xyXG4gICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxuICAgIHZhciBnID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pLCBpLCBxID0gW107XHJcbiAgICByZXR1cm4gaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIpLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGk7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgaWYgKGdbbl0pIGlbbl0gPSBmdW5jdGlvbiAodikgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKGEsIGIpIHsgcS5wdXNoKFtuLCB2LCBhLCBiXSkgPiAxIHx8IHJlc3VtZShuLCB2KTsgfSk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHJlc3VtZShuLCB2KSB7IHRyeSB7IHN0ZXAoZ1tuXSh2KSk7IH0gY2F0Y2ggKGUpIHsgc2V0dGxlKHFbMF1bM10sIGUpOyB9IH1cclxuICAgIGZ1bmN0aW9uIHN0ZXAocikgeyByLnZhbHVlIGluc3RhbmNlb2YgX19hd2FpdCA/IFByb21pc2UucmVzb2x2ZShyLnZhbHVlLnYpLnRoZW4oZnVsZmlsbCwgcmVqZWN0KSA6IHNldHRsZShxWzBdWzJdLCByKTsgfVxyXG4gICAgZnVuY3Rpb24gZnVsZmlsbCh2YWx1ZSkgeyByZXN1bWUoXCJuZXh0XCIsIHZhbHVlKTsgfVxyXG4gICAgZnVuY3Rpb24gcmVqZWN0KHZhbHVlKSB7IHJlc3VtZShcInRocm93XCIsIHZhbHVlKTsgfVxyXG4gICAgZnVuY3Rpb24gc2V0dGxlKGYsIHYpIHsgaWYgKGYodiksIHEuc2hpZnQoKSwgcS5sZW5ndGgpIHJlc3VtZShxWzBdWzBdLCBxWzBdWzFdKTsgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hc3luY0RlbGVnYXRvcihvKSB7XHJcbiAgICB2YXIgaSwgcDtcclxuICAgIHJldHVybiBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiwgZnVuY3Rpb24gKGUpIHsgdGhyb3cgZTsgfSksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGk7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4sIGYpIHsgaVtuXSA9IG9bbl0gPyBmdW5jdGlvbiAodikgeyByZXR1cm4gKHAgPSAhcCkgPyB7IHZhbHVlOiBfX2F3YWl0KG9bbl0odikpLCBkb25lOiBuID09PSBcInJldHVyblwiIH0gOiBmID8gZih2KSA6IHY7IH0gOiBmOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2FzeW5jVmFsdWVzKG8pIHtcclxuICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbiAgICB2YXIgbSA9IG9bU3ltYm9sLmFzeW5jSXRlcmF0b3JdLCBpO1xyXG4gICAgcmV0dXJuIG0gPyBtLmNhbGwobykgOiAobyA9IHR5cGVvZiBfX3ZhbHVlcyA9PT0gXCJmdW5jdGlvblwiID8gX192YWx1ZXMobykgOiBvW1N5bWJvbC5pdGVyYXRvcl0oKSwgaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIpLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGkpO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IGlbbl0gPSBvW25dICYmIGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7IHYgPSBvW25dKHYpLCBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCB2LmRvbmUsIHYudmFsdWUpOyB9KTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgZCwgdikgeyBQcm9taXNlLnJlc29sdmUodikudGhlbihmdW5jdGlvbih2KSB7IHJlc29sdmUoeyB2YWx1ZTogdiwgZG9uZTogZCB9KTsgfSwgcmVqZWN0KTsgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19tYWtlVGVtcGxhdGVPYmplY3QoY29va2VkLCByYXcpIHtcclxuICAgIGlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNvb2tlZCwgXCJyYXdcIiwgeyB2YWx1ZTogcmF3IH0pOyB9IGVsc2UgeyBjb29rZWQucmF3ID0gcmF3OyB9XHJcbiAgICByZXR1cm4gY29va2VkO1xyXG59O1xyXG5cclxudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9IE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xyXG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcclxuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcclxufTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2ltcG9ydFN0YXIobW9kKSB7XHJcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xyXG4gICAgdmFyIHJlc3VsdCA9IHt9O1xyXG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xyXG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2ltcG9ydERlZmF1bHQobW9kKSB7XHJcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IGRlZmF1bHQ6IG1vZCB9O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19jbGFzc1ByaXZhdGVGaWVsZEdldChyZWNlaXZlciwgc3RhdGUsIGtpbmQsIGYpIHtcclxuICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIGdldHRlclwiKTtcclxuICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHJlYWQgcHJpdmF0ZSBtZW1iZXIgZnJvbSBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xyXG4gICAgcmV0dXJuIGtpbmQgPT09IFwibVwiID8gZiA6IGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyKSA6IGYgPyBmLnZhbHVlIDogc3RhdGUuZ2V0KHJlY2VpdmVyKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fY2xhc3NQcml2YXRlRmllbGRTZXQocmVjZWl2ZXIsIHN0YXRlLCB2YWx1ZSwga2luZCwgZikge1xyXG4gICAgaWYgKGtpbmQgPT09IFwibVwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBtZXRob2QgaXMgbm90IHdyaXRhYmxlXCIpO1xyXG4gICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgc2V0dGVyXCIpO1xyXG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3Qgd3JpdGUgcHJpdmF0ZSBtZW1iZXIgdG8gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcclxuICAgIHJldHVybiAoa2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIsIHZhbHVlKSA6IGYgPyBmLnZhbHVlID0gdmFsdWUgOiBzdGF0ZS5zZXQocmVjZWl2ZXIsIHZhbHVlKSksIHZhbHVlO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19jbGFzc1ByaXZhdGVGaWVsZEluKHN0YXRlLCByZWNlaXZlcikge1xyXG4gICAgaWYgKHJlY2VpdmVyID09PSBudWxsIHx8ICh0eXBlb2YgcmVjZWl2ZXIgIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIHJlY2VpdmVyICE9PSBcImZ1bmN0aW9uXCIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHVzZSAnaW4nIG9wZXJhdG9yIG9uIG5vbi1vYmplY3RcIik7XHJcbiAgICByZXR1cm4gdHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciA9PT0gc3RhdGUgOiBzdGF0ZS5oYXMocmVjZWl2ZXIpO1xyXG59XHJcbiIsImltcG9ydCB7IEJ5dGVzIH0gZnJvbSBcIm5vZGUtZm9yZ2VcIjtcbmltcG9ydCB7IGNyZWF0ZUhhc2gsIHJhbmRvbUJ5dGVzIH0gZnJvbSBcImNyeXB0b1wiO1xuXG5jb25zdCBoZWFkZXJQcml2YXRlS2V5ID0gXCItLS0tLUJFR0lOIFBSSVZBVEUgS0VZLS0tLS1cXG5cIjtcbmNvbnN0IGZvb3RlclByaXZhdGVLZXkgPSBcIlxcbi0tLS0tRU5EIFBSSVZBVEUgS0VZLS0tLS1cIjtcbmNvbnN0IGhlYWRlclB1YmxpY0tleSA9IFwiLS0tLS1CRUdJTiBQVUJMSUMgS0VZLS0tLS1cXG5cIjtcbmNvbnN0IGZvb3RlclB1YmxpY0tleSA9IFwiXFxuLS0tLS1FTkQgUFVCTElDIEtFWS0tLS0tXCI7XG5cbmV4cG9ydCBjb25zdCB0b0J5dGVzID0gKGJ1ZjogQnVmZmVyKTogQnl0ZXMgPT4ge1xuICBsZXQgYnl0ZVN0cmluZyA9IFwiXCI7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYnVmLmxlbmd0aDsgKytpKSB7XG4gICAgYnl0ZVN0cmluZyArPSBTdHJpbmcuZnJvbUNvZGVQb2ludChidWZbaV0pO1xuICB9XG4gIHJldHVybiBieXRlU3RyaW5nO1xufTtcblxuZXhwb3J0IHR5cGUgS2V5VHlwZSA9IFwicHJpdmF0ZVwiIHwgXCJwdWJsaWNcIjtcblxuZXhwb3J0IGNvbnN0IGlzQXJyYXkgPSAoYTogYW55KSA9PiB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KGEpO1xufTtcblxuZXhwb3J0IGNvbnN0IGlzT2JqZWN0ID0gKG86IGFueSkgPT4ge1xuICByZXR1cm4gbyA9PT0gT2JqZWN0KG8pICYmICFpc0FycmF5KG8pICYmIHR5cGVvZiBvICE9PSBcImZ1bmN0aW9uXCI7XG59O1xuXG5leHBvcnQgY29uc3Qgc2hhMjU2ID0gKHZhbHVlOiBhbnkpID0+IHtcbiAgaWYgKGlzT2JqZWN0KHZhbHVlKSB8fCBpc0FycmF5KHZhbHVlKSkge1xuICAgIGNvbnN0IGJhc2U2NCA9IGNyZWF0ZUhhc2goXCJzaGEyNTZcIilcbiAgICAgIC51cGRhdGUoSlNPTi5zdHJpbmdpZnkodmFsdWUpKVxuICAgICAgLmRpZ2VzdChcImJhc2U2NFwiKTtcbiAgICByZXR1cm4gYmFzZTY0VG9CYXNlNjRVcmxFbmNvZGVkKGJhc2U2NCk7XG4gIH1cbiAgY29uc3QgYmFzZTY0ID0gY3JlYXRlSGFzaChcInNoYTI1NlwiKS51cGRhdGUodmFsdWUpLmRpZ2VzdChcImJhc2U2NFwiKTtcbiAgcmV0dXJuIGJhc2U2NFRvQmFzZTY0VXJsRW5jb2RlZChiYXNlNjQpO1xufTtcblxuZXhwb3J0IGNvbnN0IGdlbmVyYXRlQ29tbWl0bWVudCA9IChieXRlcz86IG51bWJlcik6IHN0cmluZyA9PiB7XG4gIGNvbnN0IGIgPSBieXRlcyB8fCAzMjtcbiAgcmV0dXJuIGJhc2U2NFRvQmFzZTY0VXJsRW5jb2RlZChyYW5kb21CeXRlcyhiKS50b1N0cmluZyhcImJhc2U2NFwiKSk7XG59O1xuXG5leHBvcnQgY29uc3QgZXh0cmFjdEJ1ZmZlciA9IChwZW1TdHJpbmc6IHN0cmluZywgdHlwZTogS2V5VHlwZSk6IEJ1ZmZlciA9PiB7XG4gIGlmICh0eXBlID09PSBcInB1YmxpY1wiKSB7XG4gICAgbGV0IGZvcm1hdHRlZFB1YmxpY0tleVBlbSA9IHBlbVN0cmluZy5zdGFydHNXaXRoKGhlYWRlclB1YmxpY0tleSlcbiAgICAgID8gcGVtU3RyaW5nLnNwbGl0KGhlYWRlclB1YmxpY0tleSlbMV1cbiAgICAgIDogcGVtU3RyaW5nO1xuICAgIGZvcm1hdHRlZFB1YmxpY0tleVBlbSA9IGZvcm1hdHRlZFB1YmxpY0tleVBlbS5lbmRzV2l0aChmb290ZXJQdWJsaWNLZXkpXG4gICAgICA/IGZvcm1hdHRlZFB1YmxpY0tleVBlbS5zcGxpdChmb290ZXJQdWJsaWNLZXkpWzBdXG4gICAgICA6IGZvcm1hdHRlZFB1YmxpY0tleVBlbTtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oZm9ybWF0dGVkUHVibGljS2V5UGVtLnJlcGxhY2UoL1xcci9nLCBcIlwiKSwgXCJiYXNlNjRcIik7XG4gIH0gZWxzZSB7XG4gICAgbGV0IGZvcm1hdHRlZFByaXZhdGVLZXlQZW0gPSBwZW1TdHJpbmcuc3RhcnRzV2l0aChoZWFkZXJQcml2YXRlS2V5KVxuICAgICAgPyBwZW1TdHJpbmcuc3BsaXQoaGVhZGVyUHJpdmF0ZUtleSlbMV1cbiAgICAgIDogcGVtU3RyaW5nO1xuICAgIGZvcm1hdHRlZFByaXZhdGVLZXlQZW0gPSBmb3JtYXR0ZWRQcml2YXRlS2V5UGVtLmVuZHNXaXRoKGZvb3RlclByaXZhdGVLZXkpXG4gICAgICA/IGZvcm1hdHRlZFByaXZhdGVLZXlQZW0uc3BsaXQoZm9vdGVyUHJpdmF0ZUtleSlbMF1cbiAgICAgIDogZm9ybWF0dGVkUHJpdmF0ZUtleVBlbTtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oZm9ybWF0dGVkUHJpdmF0ZUtleVBlbS5yZXBsYWNlKC9cXHIvZywgXCJcIiksIFwiYmFzZTY0XCIpO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgcGVtRm9ybWF0ID0gKGJ1ZmZlcjogQnVmZmVyLCB0eXBlOiBLZXlUeXBlKTogc3RyaW5nID0+IHtcbiAgaWYgKHR5cGUgPT09IFwicHVibGljXCIpIHtcbiAgICBjb25zdCBiYXNlNjQgPSBidWZmZXIudG9TdHJpbmcoXCJiYXNlNjRcIik7XG4gICAgaWYgKGJhc2U2NC5pbmNsdWRlcyhcIlxcblwiKSkge1xuICAgICAgcmV0dXJuIGAke2hlYWRlclB1YmxpY0tleX0ke2Jhc2U2NH0ke2Zvb3RlclB1YmxpY0tleX1gO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICBjb25zdCBrZXkgPSBiYXNlNjQubWF0Y2goLy57MSw2NH0vZykuam9pbihcIlxcblwiKTtcbiAgICAgIHJldHVybiBgJHtoZWFkZXJQdWJsaWNLZXl9JHtrZXl9JHtmb290ZXJQdWJsaWNLZXl9YDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgYmFzZTY0ID0gYnVmZmVyLnRvU3RyaW5nKFwiYmFzZTY0XCIpO1xuICAgIGlmIChiYXNlNjQuaW5jbHVkZXMoXCJcXG5cIikpIHtcbiAgICAgIHJldHVybiBgJHtoZWFkZXJQcml2YXRlS2V5fSR7YmFzZTY0fSR7Zm9vdGVyUHJpdmF0ZUtleX1gO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICBjb25zdCBrZXkgPSBiYXNlNjQubWF0Y2goLy57MSw2NH0vZykuam9pbihcIlxcblwiKTtcbiAgICAgIHJldHVybiBgJHtoZWFkZXJQcml2YXRlS2V5fSR7a2V5fSR7Zm9vdGVyUHJpdmF0ZUtleX1gO1xuICAgIH1cbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IGJ1ZmZlclRvQmFzZTY0VXJsRW5jb2RlZCA9IChidWZmZXI6IEJ1ZmZlcik6IHN0cmluZyA9PiB7XG4gIGNvbnN0IGJhc2U2NCA9IGJ1ZmZlci50b1N0cmluZyhcImJhc2U2NFwiKTtcbiAgcmV0dXJuIGJhc2U2NFRvQmFzZTY0VXJsRW5jb2RlZChiYXNlNjQpO1xufTtcblxuZXhwb3J0IGNvbnN0IGJhc2U2NFRvQmFzZTY0VXJsRW5jb2RlZCA9IChiYXNlNjQ6IHN0cmluZyk6IHN0cmluZyA9PiB7XG4gIHJldHVybiBiYXNlNjQucmVwbGFjZSgvPS9nLCBcIlwiKS5yZXBsYWNlKC9cXCsvZywgXCItXCIpLnJlcGxhY2UoL1xcLy9nLCBcIl9cIik7XG59O1xuXG5leHBvcnQgY29uc3QgYmFzZTY0VXJsVG9CYXNlNjRFbmNvZGVkID0gKGJhc2U2NFVybDogc3RyaW5nKTogc3RyaW5nID0+IHtcbiAgcmV0dXJuIHBhZFN0cmluZyhiYXNlNjRVcmwpLnJlcGxhY2UoL1xcLS9nLCBcIitcIikucmVwbGFjZSgvXy9nLCBcIi9cIik7XG59O1xuXG5leHBvcnQgY29uc3QgYmFzZTY0VXJsVG9CdWZmZXIgPSAoYmFzZTY0VXJsOiBzdHJpbmcpOiBCdWZmZXIgPT4ge1xuICBjb25zdCBiYXNlNjQgPSBiYXNlNjRVcmxUb0Jhc2U2NEVuY29kZWQoYmFzZTY0VXJsKTtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKGJhc2U2NCwgXCJiYXNlNjRcIik7XG59O1xuXG5leHBvcnQgY29uc3Qgc2hhMjU2QnlFYWNoRmllbGQgPSAobzogYW55KTogYW55ID0+IHtcbiAgaWYgKGlzT2JqZWN0KG8pKSB7XG4gICAgY29uc3QgbiA9IHt9O1xuXG4gICAgT2JqZWN0LmtleXMobykuZm9yRWFjaCgoazogc3RyaW5nKSA9PiB7XG4gICAgICBpZiAoayA9PT0gXCJ2ZXJpZmllZFwiKSB7XG4gICAgICAgIC8vIElnbm9yZSBgdmVyaWZpZWRgIGZsYWdcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBuW2tdID0gb1trXTtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgfSBlbHNlIGlmIChvW2tdID09PSBcIlwiIHx8IG9ba10gPT09IG51bGwpIHtcbiAgICAgICAgLy8gSWdub3JlIGVtcHR5IHZhbHVlc1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIG5ba10gPSBvW2tdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBuW2tdID0gc2hhMjU2QnlFYWNoRmllbGQob1trXSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIG47XG4gIH1cbiAgaWYgKGlzQXJyYXkobykpIHtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgcmV0dXJuIG8ubWFwKChpKSA9PiBzaGEyNTZCeUVhY2hGaWVsZChpKSk7XG4gIH1cblxuICByZXR1cm4gc2hhMjU2KG8pO1xufTtcblxuY29uc3QgcGFkU3RyaW5nID0gKGlucHV0OiBzdHJpbmcpOiBzdHJpbmcgPT4ge1xuICBjb25zdCBzZWdtZW50TGVuZ3RoID0gNDtcbiAgY29uc3Qgc3RyaW5nTGVuZ3RoID0gaW5wdXQubGVuZ3RoO1xuICBjb25zdCBkaWZmID0gc3RyaW5nTGVuZ3RoICUgc2VnbWVudExlbmd0aDtcblxuICBpZiAoIWRpZmYpIHtcbiAgICByZXR1cm4gaW5wdXQ7XG4gIH1cblxuICBsZXQgcG9zaXRpb24gPSBzdHJpbmdMZW5ndGg7XG4gIGxldCBwYWRMZW5ndGggPSBzZWdtZW50TGVuZ3RoIC0gZGlmZjtcbiAgY29uc3QgcGFkZGVkU3RyaW5nTGVuZ3RoID0gc3RyaW5nTGVuZ3RoICsgcGFkTGVuZ3RoO1xuICBsZXQgYnVmZmVyID0gQnVmZmVyLmFsbG9jKHBhZGRlZFN0cmluZ0xlbmd0aCk7XG5cbiAgYnVmZmVyLndyaXRlKGlucHV0KTtcblxuICB3aGlsZSAocGFkTGVuZ3RoLS0pIHtcbiAgICBidWZmZXIud3JpdGUoXCI9XCIsIHBvc2l0aW9uKyspO1xuICB9XG5cbiAgcmV0dXJuIGJ1ZmZlci50b1N0cmluZygpO1xufTtcblxuLyoqXG4gKiBVbmlmeSB0aGUgSnNvbiBkYXRhXG4gKiBAcGFyYW0gZGF0YSAtIGNhbiBiZSBhbnkgdHlwZVxuICogUmV0dXJuIHRoZSBvcmRlcmVkIGpzb24gb2JqZWN0XG4gKi9cblxuZXhwb3J0IGNvbnN0IHVuaWZ5SnNvbkRhdGEgPSAodW5vcmRlcmVkT2JqZWN0OiBhbnkpID0+IHtcbiAgaWYgKCF1bm9yZGVyZWRPYmplY3QpIHtcbiAgICByZXR1cm4gdW5vcmRlcmVkT2JqZWN0O1xuICB9XG5cbiAgaWYgKHR5cGVvZiB1bm9yZGVyZWRPYmplY3QgIT09IFwib2JqZWN0XCIpIHtcbiAgICByZXR1cm4gdW5vcmRlcmVkT2JqZWN0O1xuICB9XG5cbiAgcmV0dXJuIE9iamVjdC5rZXlzKHVub3JkZXJlZE9iamVjdClcbiAgICAuc29ydCgpXG4gICAgLnJlZHVjZSgocmVzLCBrZXkpID0+IHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHVub3JkZXJlZE9iamVjdFtrZXldKSkge1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHJlc1trZXldID0gdW5vcmRlcmVkT2JqZWN0W2tleV0ubWFwKHVuaWZ5SnNvbkRhdGEpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdW5vcmRlcmVkT2JqZWN0W2tleV0gPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICByZXNba2V5XSA9IHVuaWZ5SnNvbkRhdGEodW5vcmRlcmVkT2JqZWN0W2tleV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICByZXNba2V5XSA9IHVub3JkZXJlZE9iamVjdFtrZXldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlcztcbiAgICB9LCB7fSk7XG59O1xuXG5jb25zdCB0b0NhbWVsID0gKHM6IHN0cmluZyk6IHN0cmluZyA9PiB7XG4gIHJldHVybiBzLnJlcGxhY2UoLyhbLV9dW2Etel0pL2dpLCAoJDEpID0+IHtcbiAgICByZXR1cm4gJDEudG9VcHBlckNhc2UoKS5yZXBsYWNlKFwiLVwiLCBcIlwiKS5yZXBsYWNlKFwiX1wiLCBcIlwiKTtcbiAgfSk7XG59O1xuXG5jb25zdCB0b1NuYWtlID0gKHM6IHN0cmluZyk6IHN0cmluZyA9PiB7XG4gIGNvbnN0IHJlc3VsdCA9IHMucmVwbGFjZSgvKFtBLVpdKS9nLCBcIiAkMVwiKTtcbiAgcmV0dXJuIHJlc3VsdC5zcGxpdChcIiBcIikuam9pbihcIl9cIikudG9Mb3dlckNhc2UoKTtcbn07XG5cbmV4cG9ydCBjb25zdCBjYW1lbGl6ZSA9IChvOiBhbnkpOiBhbnkgPT4ge1xuICBpZiAoaXNPYmplY3QobykpIHtcbiAgICBjb25zdCBuID0ge307XG5cbiAgICBPYmplY3Qua2V5cyhvKS5mb3JFYWNoKChrKSA9PiB7XG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICBuW3RvQ2FtZWwoayldID0gY2FtZWxpemUob1trXSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIG47XG4gIH0gZWxzZSBpZiAoaXNBcnJheShvKSkge1xuICAgIHJldHVybiBvLm1hcCgoaTogYW55KSA9PiB7XG4gICAgICByZXR1cm4gY2FtZWxpemUoaSk7XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gbztcbn07XG5cbmV4cG9ydCBjb25zdCBkZWNhbWVsaXplID0gKG86IGFueSk6IGFueSA9PiB7XG4gIGlmIChpc09iamVjdChvKSkge1xuICAgIGNvbnN0IG4gPSB7fTtcblxuICAgIE9iamVjdC5rZXlzKG8pLmZvckVhY2goKGspID0+IHtcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIG5bdG9TbmFrZShrKV0gPSBkZWNhbWVsaXplKG9ba10pO1xuICAgIH0pO1xuICAgIHJldHVybiBuO1xuICB9IGVsc2UgaWYgKGlzQXJyYXkobykpIHtcbiAgICByZXR1cm4gby5tYXAoKGk6IGFueSkgPT4ge1xuICAgICAgcmV0dXJuIGRlY2FtZWxpemUoaSk7XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gbztcbn07XG4iLCIvLyBAdHMtaWdub3JlXG5pbXBvcnQgKiBhcyB3ZWJjcnlwdG8gZnJvbSBcIkBwZWN1bGlhci93ZWJjcnlwdG9cIjtcbmltcG9ydCB7XG4gIGNvbXBvc2VQcml2YXRlS2V5LFxuICBkZWNvbXBvc2VQcml2YXRlS2V5LFxufSBmcm9tIFwiQGNyZWRpZnkvY3J5cHRvLWtleS1jb21wb3NlclwiO1xuaW1wb3J0IHtcbiAgYmFzZTY0VXJsVG9CYXNlNjRFbmNvZGVkLFxuICBidWZmZXJUb0Jhc2U2NFVybEVuY29kZWQsXG4gIGV4dHJhY3RCdWZmZXIsXG4gIGlzQXJyYXksXG4gIGlzT2JqZWN0LFxuICBwZW1Gb3JtYXQsXG59IGZyb20gXCIuL3V0aWxzXCI7XG5pbXBvcnQgdHlwZSB7IEVuY3J5cHRpb24gYXMgSUVuY3J5cHRpb24gfSBmcm9tIFwiLi4vdHlwZXNcIjtcblxuZXhwb3J0IGNvbnN0IERFRkFVTFRfS0VZX1NJWkUgPSAzMDcyO1xuXG5jbGFzcyBFbmNyeXB0aW9uIGltcGxlbWVudHMgSUVuY3J5cHRpb24ge1xuICBwcml2YXRlIF9jcnlwdG86IENyeXB0bztcbiAgcHJpdmF0ZSBfcHJpdmF0ZUtleTogQ3J5cHRvS2V5O1xuICBwcml2YXRlIF9wdWJsaWNLZXk6IENyeXB0b0tleTtcblxuICBwdWJsaWMgZ2V0IHByaXZhdGVLZXkoKTogQ3J5cHRvS2V5IHtcbiAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZUtleTtcbiAgfVxuICBwdWJsaWMgZ2V0IHB1YmxpY0tleSgpOiBDcnlwdG9LZXkge1xuICAgIHJldHVybiB0aGlzLl9wdWJsaWNLZXk7XG4gIH1cblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBjb25zdCBjaGVja0lzQnJvd3NlciA9IG5ldyBGdW5jdGlvbihcbiAgICAgIFwidHJ5IHtyZXR1cm4gdGhpcz09PXdpbmRvdzt9Y2F0Y2goZSl7IHJldHVybiBmYWxzZTt9XCJcbiAgICApO1xuICAgIGNvbnN0IGlzQnJvd3NlciA9IGNoZWNrSXNCcm93c2VyKCk7XG4gICAgaWYgKGlzQnJvd3Nlcikge1xuICAgICAgdGhpcy5fY3J5cHRvID0gY3J5cHRvO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9jcnlwdG8gPSBuZXcgd2ViY3J5cHRvLkNyeXB0bygpO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBnZW5lcmF0ZUtleVBhaXIoXG4gICAga2V5U2l6ZTogbnVtYmVyID0gREVGQVVMVF9LRVlfU0laRVxuICApOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCBrZXlzID0gYXdhaXQgdGhpcy5fY3J5cHRvLnN1YnRsZS5nZW5lcmF0ZUtleShcbiAgICAgIHtcbiAgICAgICAgbmFtZTogXCJSU0EtT0FFUFwiLFxuICAgICAgICBoYXNoOiBcIlNIQS0yNTZcIixcbiAgICAgICAgcHVibGljRXhwb25lbnQ6IG5ldyBVaW50OEFycmF5KFsxLCAwLCAxXSksIC8vIDB4MDMgb3IgMHgwMTAwMDFcbiAgICAgICAgbW9kdWx1c0xlbmd0aDoga2V5U2l6ZSxcbiAgICAgIH0sXG4gICAgICB0cnVlLFxuICAgICAgW1wiZW5jcnlwdFwiLCBcImRlY3J5cHRcIl1cbiAgICApO1xuICAgIHRoaXMuX3ByaXZhdGVLZXkgPSBrZXlzLnByaXZhdGVLZXkhO1xuICAgIHRoaXMuX3B1YmxpY0tleSA9IGtleXMucHVibGljS2V5ITtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBpbXBvcnRQcml2YXRlS2V5KHBlbTogc3RyaW5nLCBwYXNzd29yZD86IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICAgIGxldCByYXdQZW0gPSBwZW07XG4gICAgaWYgKHBhc3N3b3JkKSB7XG4gICAgICBjb25zdCBkZWNvbXBvc2VkS2V5ID0gZGVjb21wb3NlUHJpdmF0ZUtleShgXFxuJHtwZW19XFxuYCwge1xuICAgICAgICBwYXNzd29yZCxcbiAgICAgICAgZm9ybWF0OiBcInBrY3M4LXBlbVwiLFxuICAgICAgfSk7XG4gICAgICAvLyBSZW1vdmUgdW5uZWNlc3NhcnkgcHJvcGVydHlcbiAgICAgIGRlbGV0ZSBkZWNvbXBvc2VkS2V5W1wiZW5jcnlwdGlvbkFsZ29yaXRobVwiXTtcbiAgICAgIHJhd1BlbSA9IGNvbXBvc2VQcml2YXRlS2V5KGRlY29tcG9zZWRLZXkpLnJlcGxhY2UoL1xcbiQvLCBcIlwiKTtcbiAgICB9XG4gICAgY29uc3QgYnVmZmVyID0gZXh0cmFjdEJ1ZmZlcihyYXdQZW0sIFwicHJpdmF0ZVwiKTtcbiAgICBjb25zdCBrZXkgPSBhd2FpdCB0aGlzLl9jcnlwdG8uc3VidGxlLmltcG9ydEtleShcbiAgICAgIFwicGtjczhcIixcbiAgICAgIGJ1ZmZlcixcbiAgICAgIHtcbiAgICAgICAgbmFtZTogXCJSU0EtT0FFUFwiLFxuICAgICAgICBoYXNoOiBcIlNIQS0yNTZcIixcbiAgICAgIH0sXG4gICAgICB0cnVlLFxuICAgICAgW1wiZGVjcnlwdFwiXVxuICAgICk7XG4gICAgdGhpcy5fcHJpdmF0ZUtleSA9IGtleTtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBpbXBvcnRQcml2YXRlS2V5SW5CYXNlNjRVcmwoXG4gICAgcGVtOiBzdHJpbmcsXG4gICAgcGFzc3dvcmQ/OiBzdHJpbmdcbiAgKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgbGV0IHJhd1BlbSA9IGJhc2U2NFVybFRvQmFzZTY0RW5jb2RlZChwZW0pO1xuICAgIHJhd1BlbSA9IHBlbUZvcm1hdChCdWZmZXIuZnJvbShyYXdQZW0sIFwiYmFzZTY0XCIpLCBcInByaXZhdGVcIik7XG4gICAgaWYgKHBhc3N3b3JkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQYXNzd29yZCBkZWNyeXB0aW9uIGlzIG5vdCBzdXBwb3J0ZWQgeWV0LlwiKTtcbiAgICAgIC8vIGNvbnN0IGRlY29tcG9zZWRLZXkgPSBkZWNvbXBvc2VQcml2YXRlS2V5KGBcXG4ke3BlbX1cXG5gLCB7IHBhc3N3b3JkLCBmb3JtYXQ6IFwicGtjczgtcGVtXCIgfSk7XG4gICAgICAvLyBSZW1vdmUgdW5uZWNlc3NhcnkgcHJvcGVydHlcbiAgICAgIC8vIGRlbGV0ZSBkZWNvbXBvc2VkS2V5W1wiZW5jcnlwdGlvbkFsZ29yaXRobVwiXTtcbiAgICAgIC8vIHJhd1BlbSA9IGNvbXBvc2VQcml2YXRlS2V5KGRlY29tcG9zZWRLZXkpO1xuICAgIH1cbiAgICBjb25zdCBidWZmZXIgPSBleHRyYWN0QnVmZmVyKHJhd1BlbSwgXCJwcml2YXRlXCIpO1xuICAgIGNvbnN0IGtleSA9IGF3YWl0IHRoaXMuX2NyeXB0by5zdWJ0bGUuaW1wb3J0S2V5KFxuICAgICAgXCJwa2NzOFwiLFxuICAgICAgYnVmZmVyLFxuICAgICAge1xuICAgICAgICBuYW1lOiBcIlJTQS1PQUVQXCIsXG4gICAgICAgIGhhc2g6IFwiU0hBLTI1NlwiLFxuICAgICAgfSxcbiAgICAgIHRydWUsXG4gICAgICBbXCJkZWNyeXB0XCJdXG4gICAgKTtcbiAgICB0aGlzLl9wcml2YXRlS2V5ID0ga2V5O1xuICB9XG5cbiAgcHVibGljIGFzeW5jIGltcG9ydFB1YmxpY0tleShwZW06IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IGJ1ZmZlciA9IGV4dHJhY3RCdWZmZXIocGVtLCBcInB1YmxpY1wiKTtcbiAgICBjb25zdCBrZXkgPSBhd2FpdCB0aGlzLl9jcnlwdG8uc3VidGxlLmltcG9ydEtleShcbiAgICAgIFwic3BraVwiLFxuICAgICAgYnVmZmVyLFxuICAgICAge1xuICAgICAgICBuYW1lOiBcIlJTQS1PQUVQXCIsXG4gICAgICAgIGhhc2g6IFwiU0hBLTI1NlwiLFxuICAgICAgfSxcbiAgICAgIHRydWUsXG4gICAgICBbXCJlbmNyeXB0XCJdXG4gICAgKTtcbiAgICB0aGlzLl9wdWJsaWNLZXkgPSBrZXk7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgaW1wb3J0UHVibGljS2V5SW5CYXNlNjRVcmwocGVtOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCBiYXNlNjQgPSBiYXNlNjRVcmxUb0Jhc2U2NEVuY29kZWQocGVtKTtcbiAgICBjb25zdCBidWZmZXIgPSBCdWZmZXIuZnJvbShiYXNlNjQsIFwiYmFzZTY0XCIpO1xuICAgIGNvbnN0IGtleSA9IGF3YWl0IHRoaXMuX2NyeXB0by5zdWJ0bGUuaW1wb3J0S2V5KFxuICAgICAgXCJzcGtpXCIsXG4gICAgICBidWZmZXIsXG4gICAgICB7XG4gICAgICAgIG5hbWU6IFwiUlNBLU9BRVBcIixcbiAgICAgICAgaGFzaDogXCJTSEEtMjU2XCIsXG4gICAgICB9LFxuICAgICAgdHJ1ZSxcbiAgICAgIFtcImVuY3J5cHRcIl1cbiAgICApO1xuICAgIHRoaXMuX3B1YmxpY0tleSA9IGtleTtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBlbmNyeXB0KGRhdGE6IEJ1ZmZlcik6IFByb21pc2U8QnVmZmVyPiB7XG4gICAgaWYgKCF0aGlzLl9wdWJsaWNLZXkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcInB1YmxpYyBrZXkgaXMgbm90IHBhc3NlZCBwcm9wZXJseS5cIik7XG4gICAgfVxuICAgIGNvbnN0IGVuYyA9IGF3YWl0IHRoaXMuX2NyeXB0by5zdWJ0bGUuZW5jcnlwdChcbiAgICAgIFwiUlNBLU9BRVBcIixcbiAgICAgIHRoaXMuX3B1YmxpY0tleSxcbiAgICAgIGRhdGFcbiAgICApO1xuICAgIHJldHVybiBCdWZmZXIuZnJvbShuZXcgVWludDhBcnJheShlbmMpKTtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBlbmNyeXB0U3RyaW5nVG9CYXNlNjRVcmxTdHJpbmcoXG4gICAgbWVzc2FnZTogc3RyaW5nXG4gICk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgaWYgKCF0aGlzLl9wdWJsaWNLZXkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcInB1YmxpYyBrZXkgaXMgbm90IHBhc3NlZCBwcm9wZXJseS5cIik7XG4gICAgfVxuXG4gICAgY29uc3QgZW5jID0gYXdhaXQgdGhpcy5yc2FMYXJnZU1lc3NhZ2VFbmNyeXB0KG1lc3NhZ2UpO1xuICAgIHJldHVybiBidWZmZXJUb0Jhc2U2NFVybEVuY29kZWQoZW5jKTtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBlbmNyeXB0RmllbGRCeUZpZWxkKHBsYWluOiBhbnkpOiBQcm9taXNlPGFueT4ge1xuICAgIGlmIChpc09iamVjdChwbGFpbikpIHtcbiAgICAgIGNvbnN0IG4gPSB7fTtcblxuICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHBsYWluKTtcbiAgICAgIGZvciAoY29uc3QgayBvZiBrZXlzKSB7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgbltrXSA9IGF3YWl0IHRoaXMuZW5jcnlwdEZpZWxkQnlGaWVsZChwbGFpbltrXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbjtcbiAgICB9IGVsc2UgaWYgKGlzQXJyYXkocGxhaW4pKSB7XG4gICAgICBjb25zdCBuID0gW107XG4gICAgICBmb3IgKGNvbnN0IGkgb2YgcGxhaW4pIHtcbiAgICAgICAgY29uc3QgZCA9IGF3YWl0IHRoaXMuZW5jcnlwdEZpZWxkQnlGaWVsZChpKTtcbiAgICAgICAgbi5wdXNoKGQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG47XG4gICAgfVxuXG4gICAgaWYgKHBsYWluID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKHBsYWluID09PSBcIlwiKSB7XG4gICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG4gICAgaWYgKHBsYWluID09PSB0cnVlKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHBsYWluID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiBhd2FpdCB0aGlzLmVuY3J5cHRTdHJpbmdUb0Jhc2U2NFVybFN0cmluZyhwbGFpbik7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgZGVjcnlwdChjaXBoZXI6IEJ1ZmZlcik6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgaWYgKCF0aGlzLl9wcml2YXRlS2V5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJwcml2YXRlIGtleSBpcyBub3QgcGFzc2VkIHByb3Blcmx5LlwiKTtcbiAgICB9XG4gICAgY29uc3QgZGVjID0gYXdhaXQgdGhpcy5fY3J5cHRvLnN1YnRsZS5kZWNyeXB0KFxuICAgICAgXCJSU0EtT0FFUFwiLFxuICAgICAgdGhpcy5fcHJpdmF0ZUtleSxcbiAgICAgIGNpcGhlclxuICAgICk7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKGRlYykudG9TdHJpbmcoXCJ1dGY4XCIpO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIGRlY3J5cHRCYXNlNjRVcmxTdHJpbmdUb1N0cmluZyhjaXBoZXI6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgY29uc3QgYmFzZTY0ID0gYmFzZTY0VXJsVG9CYXNlNjRFbmNvZGVkKGNpcGhlcik7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMucnNhTGFyZ2VNZXNzYWdlRGVjcnlwdChCdWZmZXIuZnJvbShiYXNlNjQsIFwiYmFzZTY0XCIpKTtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBkZWNyeXB0RmllbGRCeUZpZWxkKGNpcGhlcjogYW55KTogUHJvbWlzZTxhbnk+IHtcbiAgICBpZiAoaXNPYmplY3QoY2lwaGVyKSkge1xuICAgICAgY29uc3QgbiA9IHt9O1xuXG4gICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoY2lwaGVyKTtcbiAgICAgIGZvciAoY29uc3QgayBvZiBrZXlzKSB7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgbltrXSA9IGF3YWl0IHRoaXMuZGVjcnlwdEZpZWxkQnlGaWVsZChjaXBoZXJba10pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG47XG4gICAgfSBlbHNlIGlmIChpc0FycmF5KGNpcGhlcikpIHtcbiAgICAgIGNvbnN0IG4gPSBbXTtcbiAgICAgIGZvciAoY29uc3QgaSBvZiBjaXBoZXIpIHtcbiAgICAgICAgY29uc3QgZCA9IGF3YWl0IHRoaXMuZGVjcnlwdEZpZWxkQnlGaWVsZChpKTtcbiAgICAgICAgbi5wdXNoKGQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG47XG4gICAgfVxuXG4gICAgaWYgKGNpcGhlciA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmIChjaXBoZXIgPT09IFwiXCIpIHtcbiAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cbiAgICBpZiAoY2lwaGVyID09PSB0cnVlKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGNpcGhlciA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXdhaXQgdGhpcy5kZWNyeXB0QmFzZTY0VXJsU3RyaW5nVG9TdHJpbmcoY2lwaGVyKTtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBleHBvcnRQcml2YXRlS2V5KHBhc3N3b3JkPzogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICBpZiAoIXRoaXMuX3ByaXZhdGVLZXkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcInByaXZhdGUga2V5IGlzIG5vdCBpbnN0YW50aWF0ZWQuXCIpO1xuICAgIH1cblxuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLl9jcnlwdG8uc3VidGxlLmV4cG9ydEtleShcInBrY3M4XCIsIHRoaXMuX3ByaXZhdGVLZXkpO1xuICAgIGNvbnN0IHJhd1BlbSA9IHBlbUZvcm1hdChCdWZmZXIuZnJvbShkYXRhKSwgXCJwcml2YXRlXCIpO1xuICAgIGlmICghcGFzc3dvcmQpIHtcbiAgICAgIHJldHVybiByYXdQZW07XG4gICAgfVxuXG4gICAgY29uc3QgZGVjb21wb3NlZEtleSA9IGRlY29tcG9zZVByaXZhdGVLZXkoYFxcbiR7cmF3UGVtfVxcbmAsIHtcbiAgICAgIGZvcm1hdDogXCJwa2NzOC1wZW1cIixcbiAgICB9KTtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgZGVjb21wb3NlZEtleVtcImVuY3J5cHRpb25BbGdvcml0aG1cIl0gPSB7XG4gICAgICBrZXlEZXJpdmF0aW9uRnVuYzoge1xuICAgICAgICBpZDogXCJwYmtkZjJcIixcbiAgICAgICAgaXRlcmF0aW9uQ291bnQ6IDEwMDAwLCAvLyBUaGUgbnVtYmVyIG9mIGl0ZXJhdGlvbnNcbiAgICAgICAga2V5TGVuZ3RoOiAzMiwgLy8gQXV0b21hdGljLCBiYXNlZCBvbiB0aGUgYGVuY3J5cHRpb25TY2hlbWVgXG4gICAgICAgIHByZjogXCJobWFjLXdpdGgtc2hhMjU2XCIsIC8vIFRoZSBwc2V1ZG8tcmFuZG9tIGZ1bmN0aW9uXG4gICAgICB9LFxuICAgICAgZW5jcnlwdGlvblNjaGVtZTogXCJhZXMyNTYtY2JjXCIsXG4gICAgfTtcbiAgICByZXR1cm4gY29tcG9zZVByaXZhdGVLZXkoZGVjb21wb3NlZEtleSwgeyBwYXNzd29yZCB9KS5yZXBsYWNlKC9cXG4kLywgXCJcIik7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgZXhwb3J0UHJpdmF0ZUtleUluQmFzZTY0VXJsKCk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgY29uc3QgcHJpdmF0ZUtleSA9IGF3YWl0IHRoaXMuZXhwb3J0UHJpdmF0ZUtleSgpO1xuICAgIGNvbnN0IGJ1ZmZlciA9IGV4dHJhY3RCdWZmZXIocHJpdmF0ZUtleSwgXCJwcml2YXRlXCIpO1xuICAgIHJldHVybiBidWZmZXJUb0Jhc2U2NFVybEVuY29kZWQoYnVmZmVyKTtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBleHBvcnRQdWJsaWNLZXkoKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICBpZiAoIXRoaXMuX3B1YmxpY0tleSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwicHVibGljIGtleSBpcyBub3QgaW5zdGFudGlhdGVkLlwiKTtcbiAgICB9XG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IHRoaXMuX2NyeXB0by5zdWJ0bGUuZXhwb3J0S2V5KFwic3BraVwiLCB0aGlzLl9wdWJsaWNLZXkpO1xuICAgIHJldHVybiBwZW1Gb3JtYXQoQnVmZmVyLmZyb20oZGF0YSksIFwicHVibGljXCIpO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIGV4cG9ydFB1YmxpY0tleUluQmFzZTY0VXJsKCk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgY29uc3QgcHVibGljS2V5ID0gYXdhaXQgdGhpcy5leHBvcnRQdWJsaWNLZXkoKTtcbiAgICBjb25zdCBidWZmZXIgPSBleHRyYWN0QnVmZmVyKHB1YmxpY0tleSwgXCJwdWJsaWNcIik7XG4gICAgcmV0dXJuIGJ1ZmZlclRvQmFzZTY0VXJsRW5jb2RlZChidWZmZXIpO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIHJzYUxhcmdlTWVzc2FnZUVuY3J5cHQobXNnOiBzdHJpbmcpOiBQcm9taXNlPEJ1ZmZlcj4ge1xuICAgIGlmICghdGhpcy5wdWJsaWNLZXkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcInB1YmxpYyBrZXkgaXMgbm90IHBhc3NlZCBwcm9wZXJseS5cIik7XG4gICAgfVxuICAgIGNvbnN0IGJ1ZmZlckRhdGEgPSBCdWZmZXIuZnJvbShtc2csIFwidXRmLThcIik7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGNvbnN0IGtleVNpemUgPSB0aGlzLnB1YmxpY0tleS5hbGdvcml0aG0ubW9kdWx1c0xlbmd0aCAvIDg7XG4gICAgY29uc3QgaGFzaFNpemUgPSAzMjsgLy8gQ2F1c2Ugc2hhMjU2IGlzIGFsd2F5cyAzMiBieXRlc1xuICAgIGNvbnN0IGJsb2NrU2l6ZSA9IGtleVNpemUgLSAyICogaGFzaFNpemUgLSAyOyAvLyBtYXhpbXVtIE9BRVAgYmxvY2sgc2l6ZVxuICAgIGNvbnN0IGxlbmd0aCA9IGJ1ZmZlckRhdGEubGVuZ3RoO1xuICAgIGxldCBudW1CbG9ja3MgPSBNYXRoLmZsb29yKGxlbmd0aCAvIGJsb2NrU2l6ZSk7XG4gICAgaWYgKGxlbmd0aCAlIGJsb2NrU2l6ZSAhPT0gMCkge1xuICAgICAgbnVtQmxvY2tzICs9IDE7XG4gICAgfVxuXG4gICAgbGV0IHJlcyA9IEJ1ZmZlci5hbGxvYyhrZXlTaXplICogbnVtQmxvY2tzKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bUJsb2NrczsgaSsrKSB7XG4gICAgICBsZXQgY3VycmVudFNpemUgPSBibG9ja1NpemU7XG4gICAgICBpZiAoYnVmZmVyRGF0YS5sZW5ndGggPCAoaSArIDEpICogYmxvY2tTaXplKSB7XG4gICAgICAgIGN1cnJlbnRTaXplID0gYnVmZmVyRGF0YS5sZW5ndGggLSBpICogYmxvY2tTaXplO1xuICAgICAgfVxuICAgICAgbGV0IGJsb2NrID0gYnVmZmVyRGF0YS5zbGljZShpICogYmxvY2tTaXplLCBpICogYmxvY2tTaXplICsgY3VycmVudFNpemUpO1xuICAgICAgY29uc3QgYnVmZmVyRW5jRGF0YSA9IGF3YWl0IHRoaXMuZW5jcnlwdChibG9jayk7XG4gICAgICBmb3IgKGxldCBqID0gaSAqIGtleVNpemU7IGogPCBpICoga2V5U2l6ZSArIGJ1ZmZlckVuY0RhdGEubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgcmVzW2pdID0gYnVmZmVyRW5jRGF0YVtqIC0gaSAqIGtleVNpemVdO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIHJzYUxhcmdlTWVzc2FnZURlY3J5cHQoY2lwaGVyOiBCdWZmZXIpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgIGlmICghdGhpcy5wcml2YXRlS2V5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJwcml2YXRlIGtleSBpcyBub3QgcGFzc2VkIHByb3Blcmx5LlwiKTtcbiAgICB9XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGNvbnN0IGtleVNpemUgPSB0aGlzLnByaXZhdGVLZXkuYWxnb3JpdGhtLm1vZHVsdXNMZW5ndGggLyA4O1xuICAgIGNvbnN0IGxlbmd0aCA9IGNpcGhlci5sZW5ndGg7XG4gICAgaWYgKGxlbmd0aCAlIGtleVNpemUgIT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQga2V5IHNpemVcIik7XG4gICAgfVxuXG4gICAgY29uc3QgbnVtQmxvY2tzID0gbGVuZ3RoIC8ga2V5U2l6ZTtcbiAgICBsZXQgcmVzID0gXCJcIjtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bUJsb2NrczsgaSsrKSB7XG4gICAgICBjb25zdCBibG9jayA9IGNpcGhlci5zbGljZShpICoga2V5U2l6ZSwgKGkgKyAxKSAqIGtleVNpemUpO1xuICAgICAgY29uc3QgcHQgPSBhd2FpdCB0aGlzLmRlY3J5cHQoYmxvY2spO1xuICAgICAgcmVzICs9IHB0O1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEVuY3J5cHRpb247XG4iLCJpbXBvcnQgeyBwa2kgfSBmcm9tIFwibm9kZS1mb3JnZVwiO1xuaW1wb3J0IHsgY29tcG9zZVB1YmxpY0tleSwgY29tcG9zZVByaXZhdGVLZXksIGRlY29tcG9zZVB1YmxpY0tleSwgZGVjb21wb3NlUHJpdmF0ZUtleSB9IGZyb20gJ0BjcmVkaWZ5L2NyeXB0by1rZXktY29tcG9zZXInO1xuaW1wb3J0IHtcbiAgYmFzZTY0VG9CYXNlNjRVcmxFbmNvZGVkLFxuICBiYXNlNjRVcmxUb0Jhc2U2NEVuY29kZWQsIGJhc2U2NFVybFRvQnVmZmVyLFxuICBidWZmZXJUb0Jhc2U2NFVybEVuY29kZWQsXG4gIGV4dHJhY3RCdWZmZXIsXG4gIHBlbUZvcm1hdFxufSBmcm9tIFwiLi91dGlsc1wiO1xuaW1wb3J0IHR5cGUgeyBTaWduaW5nIGFzIElTaWduaW5nIH0gZnJvbSBcIi4uL3R5cGVzL2luZGV4XCI7XG5cbmNsYXNzIFNpZ25pbmcgaW1wbGVtZW50cyBJU2lnbmluZyB7XG4gIHByaXZhdGUgX3ByaXZhdGVLZXk6IHBraS5lZDI1NTE5LktleTtcbiAgcHJpdmF0ZSBfcHVibGljS2V5OiBwa2kuZWQyNTUxOS5LZXk7XG5cbiAgcHVibGljIGdldCBwcml2YXRlS2V5KCk6IEJ1ZmZlciB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHRoaXMuX3ByaXZhdGVLZXkpO1xuICB9XG4gIHB1YmxpYyBnZXQgcHVibGljS2V5KCk6IEJ1ZmZlciB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHRoaXMuX3B1YmxpY0tleSk7XG4gIH1cblxuICBwdWJsaWMgZ2VuZXJhdGVLZXlQYWlyKCk6IHZvaWQge1xuICAgIGNvbnN0IGtleVBhaXIgPSBwa2kuZWQyNTUxOS5nZW5lcmF0ZUtleVBhaXIoKTtcbiAgICB0aGlzLl9wcml2YXRlS2V5ID0ga2V5UGFpci5wcml2YXRlS2V5O1xuICAgIHRoaXMuX3B1YmxpY0tleSA9IGtleVBhaXIucHVibGljS2V5O1xuICB9XG5cbiAgcHVibGljIGltcG9ydFNlZWQoc2VlZDogc3RyaW5nKTogdm9pZCB7XG4gICAgY29uc3QgYnl0ZXMgPSBiYXNlNjRVcmxUb0J1ZmZlcihzZWVkKTtcbiAgICBjb25zdCBrZXlQYWlyID0gcGtpLmVkMjU1MTkuZ2VuZXJhdGVLZXlQYWlyKHsgc2VlZDogYnl0ZXMgfSk7XG4gICAgdGhpcy5fcHJpdmF0ZUtleSA9IGtleVBhaXIucHJpdmF0ZUtleTtcbiAgICB0aGlzLl9wdWJsaWNLZXkgPSBrZXlQYWlyLnB1YmxpY0tleTtcbiAgfVxuXG4gIHB1YmxpYyBpbXBvcnRQcml2YXRlS2V5KHBlbTogc3RyaW5nLCBwYXNzd29yZD86IHN0cmluZyk6IHZvaWQge1xuICAgIGNvbnN0IGRlY29tcG9zZWRLZXkgPSBkZWNvbXBvc2VQcml2YXRlS2V5KGBcXG4ke3BlbX1cXG5gLCB7IHBhc3N3b3JkLCBmb3JtYXQ6IFwicGtjczgtcGVtXCIgfSk7XG4gICAgY29uc3Qgc2VlZCA9IGRlY29tcG9zZWRLZXkua2V5RGF0YS5zZWVkO1xuICAgIGNvbnN0IGtleVBhaXIgPSBwa2kuZWQyNTUxOS5nZW5lcmF0ZUtleVBhaXIoe3NlZWR9KTtcbiAgICB0aGlzLl9wcml2YXRlS2V5ID0ga2V5UGFpci5wcml2YXRlS2V5O1xuICAgIHRoaXMuX3B1YmxpY0tleSA9IGtleVBhaXIucHVibGljS2V5O1xuICB9XG5cbiAgcHVibGljIGltcG9ydFByaXZhdGVLZXlJbkJhc2U2NFVybChwZW06IHN0cmluZywgcGFzc3dvcmQ/OiBzdHJpbmcpOiB2b2lkIHtcbiAgICBjb25zdCBwZW1EYXRhID0gYmFzZTY0VXJsVG9CYXNlNjRFbmNvZGVkKHBlbSk7XG4gICAgY29uc3QgcCA9IHBlbUZvcm1hdChCdWZmZXIuZnJvbShwZW1EYXRhLCBcImJhc2U2NFwiKSwgXCJwcml2YXRlXCIpO1xuICAgIGNvbnN0IGRlY29tcG9zZWRLZXkgPSBkZWNvbXBvc2VQcml2YXRlS2V5KGBcXG4ke3B9XFxuYCwgeyBwYXNzd29yZCwgZm9ybWF0OiBcInBrY3M4LXBlbVwiIH0pO1xuICAgIGNvbnN0IHNlZWQgPSBkZWNvbXBvc2VkS2V5LmtleURhdGEuc2VlZDtcbiAgICBjb25zdCBrZXlQYWlyID0gcGtpLmVkMjU1MTkuZ2VuZXJhdGVLZXlQYWlyKHtzZWVkfSk7XG4gICAgdGhpcy5fcHJpdmF0ZUtleSA9IGtleVBhaXIucHJpdmF0ZUtleTtcbiAgICB0aGlzLl9wdWJsaWNLZXkgPSBrZXlQYWlyLnB1YmxpY0tleTtcbiAgfVxuXG4gIHB1YmxpYyBpbXBvcnRQdWJsaWNLZXkocGVtOiBzdHJpbmcpOiB2b2lkIHtcbiAgICBjb25zdCBkZWNvbXBvc2VkS2V5ID0gZGVjb21wb3NlUHVibGljS2V5KGBcXG4ke3BlbX1cXG5gKTtcbiAgICB0aGlzLl9wdWJsaWNLZXkgPSBkZWNvbXBvc2VkS2V5LmtleURhdGEuYnl0ZXM7XG4gIH1cblxuICBwdWJsaWMgaW1wb3J0UHVibGljS2V5SW5CYXNlNjRVcmwocGVtOiBzdHJpbmcpOiB2b2lkIHtcbiAgICBjb25zdCBwZW1EYXRhID0gYmFzZTY0VXJsVG9CYXNlNjRFbmNvZGVkKHBlbSk7XG4gICAgY29uc3QgcCA9IHBlbUZvcm1hdChCdWZmZXIuZnJvbShwZW1EYXRhLCBcImJhc2U2NFwiKSwgXCJwdWJsaWNcIik7XG4gICAgY29uc3QgZGVjb21wb3NlZEtleSA9IGRlY29tcG9zZVB1YmxpY0tleShgXFxuJHtwfVxcbmApO1xuICAgIHRoaXMuX3B1YmxpY0tleSA9IGRlY29tcG9zZWRLZXkua2V5RGF0YS5ieXRlcztcbiAgfVxuXG4gIHB1YmxpYyBzaWduKG1lc3NhZ2U6IHN0cmluZywgb3B0aW9uPzogeyBpbnB1dD86IFwiYmFzZTY0XCIgfCBcInV0ZjhcIiB8IFwiaGV4XCIsIG91dHB1dD86IFwiYmFzZTY0XCIgfCBcInV0ZjhcIiB8IFwiaGV4XCIgfSApOiBzdHJpbmcge1xuICAgIGlmICghdGhpcy5fcHJpdmF0ZUtleSkgdGhyb3cgbmV3IEVycm9yKFwiUHJpdmF0ZSBrZXkgaXMgbm90IHNldCB5ZXQuXCIpO1xuICAgIGxldCBkZWNvZGVkID0gYmFzZTY0VXJsVG9CdWZmZXIobWVzc2FnZSk7XG4gICAgaWYgKG9wdGlvbj8uaW5wdXQgPT09IFwiYmFzZTY0XCIpIHsgZGVjb2RlZCA9IEJ1ZmZlci5mcm9tKG1lc3NhZ2UsIFwiYmFzZTY0XCIpIH1cbiAgICBpZiAob3B0aW9uPy5pbnB1dCA9PT0gXCJ1dGY4XCIpIHsgZGVjb2RlZCA9IEJ1ZmZlci5mcm9tKG1lc3NhZ2UpIH1cbiAgICBpZiAob3B0aW9uPy5pbnB1dCA9PT0gXCJoZXhcIikgeyBkZWNvZGVkID0gQnVmZmVyLmZyb20obWVzc2FnZSwgXCJoZXhcIikgfVxuICAgIGxldCBiYXNlNjQgPSBwa2kuZWQyNTUxOS5zaWduKHsgbWVzc2FnZTogZGVjb2RlZCwgZW5jb2Rpbmc6IFwiYmluYXJ5XCIsIHByaXZhdGVLZXk6IHRoaXMuX3ByaXZhdGVLZXkgfSkudG9TdHJpbmcoXCJiYXNlNjRcIik7XG5cbiAgICBpZiAoYmFzZTY0LmluY2x1ZGVzKFwiLFwiKSkge1xuICAgICAgLy8gRklYTUU6IE5leHQuanMgd2FzIG5vdCB3b3JraW5nIHdlbGwgd2l0aCBwa2kuZWQyNTUxOS5zaWduJ3MgZm9ybWF0XG4gICAgICBiYXNlNjQgPSBCdWZmZXIuZnJvbShiYXNlNjQuc3BsaXQoXCIsXCIpLm1hcChOdW1iZXIpKS50b1N0cmluZyhcImJhc2U2NFwiKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9uPy5vdXRwdXQgPT09IFwiYmFzZTY0XCIpIHtcbiAgICAgIHJldHVybiBiYXNlNjQ7XG4gICAgfVxuICAgIGlmIChvcHRpb24/Lm91dHB1dCA9PT0gXCJ1dGY4XCIpIHtcbiAgICAgIHJldHVybiBCdWZmZXIuZnJvbShiYXNlNjQsIFwiYmFzZTY0XCIpLnRvU3RyaW5nKFwidXRmOFwiKVxuICAgIH1cbiAgICBpZiAob3B0aW9uPy5vdXRwdXQgPT09IFwiaGV4XCIpIHtcbiAgICAgIHJldHVybiBCdWZmZXIuZnJvbShiYXNlNjQsIFwiYmFzZTY0XCIpLnRvU3RyaW5nKFwiaGV4XCIpXG4gICAgfVxuICAgIC8vIERlZmF1bHQgaXMgYmFzZTY0VVJMIGVuY29kZWQgc3RyaW5nXG4gICAgcmV0dXJuIGJhc2U2NFRvQmFzZTY0VXJsRW5jb2RlZChiYXNlNjQpO1xuICB9XG5cbiAgdmVyaWZ5KG1lc3NhZ2U6IHN0cmluZywgc2lnbmF0dXJlOiBzdHJpbmcsIG9wdGlvbj86IHsgZW5jb2RlOiBcImJhc2U2NFwiIHwgXCJiYXNlNjRVcmxcIiB9KTogYm9vbGVhbiB7XG4gICAgaWYgKCF0aGlzLl9wdWJsaWNLZXkpIHRocm93IG5ldyBFcnJvcihcIlB1YmxpYyBrZXkgaXMgbm90IHNldCB5ZXQuXCIpO1xuICAgIGxldCBzaWcgPSBcIlwiO1xuICAgIGlmIChvcHRpb24/LmVuY29kZSA9PT0gXCJiYXNlNjRcIikge1xuICAgICAgc2lnID0gc2lnbmF0dXJlO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBEZWZhdWx0IGlzIGJhc2U2NFVSTCBlbmNvZGVkIHN0cmluZ1xuICAgICAgc2lnID0gYmFzZTY0VXJsVG9CYXNlNjRFbmNvZGVkKHNpZ25hdHVyZSk7XG4gICAgfVxuICAgIHJldHVybiBwa2kuZWQyNTUxOS52ZXJpZnkoe1xuICAgICAgbWVzc2FnZSxcbiAgICAgIGVuY29kaW5nOiBcImJpbmFyeVwiLFxuICAgICAgc2lnbmF0dXJlOiBCdWZmZXIuZnJvbShzaWcsIFwiYmFzZTY0XCIpLFxuICAgICAgcHVibGljS2V5OiB0aGlzLl9wdWJsaWNLZXlcbiAgICB9KVxuICB9XG5cbiAgcHVibGljIGV4cG9ydFByaXZhdGVLZXkocGFzc3dvcmQ/OiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIGlmICghdGhpcy5fcHJpdmF0ZUtleSkgeyB0aHJvdyBuZXcgRXJyb3IoXCJwcml2YXRlIGtleSBpcyBub3QgaW5zdGFudGlhdGVkLlwiKSB9XG5cbiAgICBjb25zdCBkZWNvbXBvc2VkID0ge1xuICAgICAgZm9ybWF0OiAncGtjczgtcGVtJyxcbiAgICAgIGtleUFsZ29yaXRobTogeyBpZDogJ2VkMjU1MTknIH0sXG4gICAgICBrZXlEYXRhOiB7XG4gICAgICAgIHNlZWQ6IHRoaXMuX3ByaXZhdGVLZXkuc2xpY2UoMCwgMzIpLFxuICAgICAgfSxcbiAgICB9O1xuICAgIGlmIChwYXNzd29yZCkge1xuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgZGVjb21wb3NlZFtcImVuY3J5cHRpb25BbGdvcml0aG1cIl0gPSB7XG4gICAgICAgIGtleURlcml2YXRpb25GdW5jOiB7XG4gICAgICAgICAgaWQ6ICdwYmtkZjInLFxuICAgICAgICAgIGl0ZXJhdGlvbkNvdW50OiAxMDAwMCwgIC8vIFRoZSBudW1iZXIgb2YgaXRlcmF0aW9uc1xuICAgICAgICAgIGtleUxlbmd0aDogMzIsIC8vIEF1dG9tYXRpYywgYmFzZWQgb24gdGhlIGBlbmNyeXB0aW9uU2NoZW1lYFxuICAgICAgICAgIHByZjogJ2htYWMtd2l0aC1zaGEyNTYnICAvLyBUaGUgcHNldWRvLXJhbmRvbSBmdW5jdGlvblxuICAgICAgICB9LFxuICAgICAgICBlbmNyeXB0aW9uU2NoZW1lOiAnYWVzMjU2LWNiYycsXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjb21wb3NlUHJpdmF0ZUtleShkZWNvbXBvc2VkLCB7IHBhc3N3b3JkIH0pLnJlcGxhY2UoL1xcbiQvLCBcIlwiKTtcbiAgfVxuXG4gIHB1YmxpYyBleHBvcnRQdWJsaWNLZXkoKTogc3RyaW5nIHtcbiAgICBpZiAoIXRoaXMuX3B1YmxpY0tleSkgeyB0aHJvdyBuZXcgRXJyb3IoXCJwdWJsaWMga2V5IGlzIG5vdCBpbnN0YW50aWF0ZWQuXCIpIH1cbiAgICBjb25zdCBkZWNvbXBvc2VkID0ge1xuICAgICAgZm9ybWF0OiAnc3BraS1wZW0nLFxuICAgICAga2V5QWxnb3JpdGhtOiB7IGlkOiAnZWQyNTUxOScgfSxcbiAgICAgIGtleURhdGE6IHtcbiAgICAgICAgYnl0ZXM6IHRoaXMuX3B1YmxpY0tleSxcbiAgICAgIH0sXG4gICAgfTtcbiAgICByZXR1cm4gY29tcG9zZVB1YmxpY0tleShkZWNvbXBvc2VkKS5yZXBsYWNlKC9cXG4kLywgXCJcIik7XG4gIH1cblxuICBwdWJsaWMgZXhwb3J0UHJpdmF0ZUtleUluQmFzZTY0VXJsKCk6IHN0cmluZyB7XG4gICAgY29uc3QgcHJpdlBlbSA9IHRoaXMuZXhwb3J0UHJpdmF0ZUtleSgpO1xuICAgIGNvbnN0IGJ1ZmZlciA9IGV4dHJhY3RCdWZmZXIocHJpdlBlbSwgXCJwcml2YXRlXCIpO1xuICAgIHJldHVybiBidWZmZXJUb0Jhc2U2NFVybEVuY29kZWQoYnVmZmVyKTtcbiAgfVxuXG4gIHB1YmxpYyBleHBvcnRQdWJsaWNLZXlJbkJhc2U2NFVybCgpOiBzdHJpbmcge1xuICAgIGNvbnN0IHB1YlBlbSA9IHRoaXMuZXhwb3J0UHVibGljS2V5KCk7XG4gICAgY29uc3QgcHViQnVmZmVyID0gZXh0cmFjdEJ1ZmZlcihwdWJQZW0sIFwicHVibGljXCIpO1xuICAgIHJldHVybiBidWZmZXJUb0Jhc2U2NFVybEVuY29kZWQocHViQnVmZmVyKTtcbiAgfVxuXG4gIHB1YmxpYyBleHBvcnRTZWVkKCk6IHN0cmluZyB7XG4gICAgY29uc3Qgc2VlZERhdGEgPSB0aGlzLl9wcml2YXRlS2V5LnNsaWNlKDAsIDMyKTtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgcmV0dXJuIGJ1ZmZlclRvQmFzZTY0VXJsRW5jb2RlZChzZWVkRGF0YSk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgU2lnbmluZztcbiIsImltcG9ydCB0eXBlIHsgSldUSGVhZGVyLCBKV1RQYXlsb2FkLCBKV1RUeXBlIH0gZnJvbSBcIi4uL3R5cGVzXCI7XG5pbXBvcnQgU2lnbmluZyBmcm9tIFwiQC9zaWduaW5nXCI7XG5pbXBvcnQge1xuICBiYXNlNjRUb0Jhc2U2NFVybEVuY29kZWQsXG4gIGJhc2U2NFVybFRvQmFzZTY0RW5jb2RlZCxcbiAgZ2VuZXJhdGVDb21taXRtZW50LFxuICBzaGEyNTYsXG4gIHVuaWZ5SnNvbkRhdGEsXG59IGZyb20gXCIuL3V0aWxzXCI7XG5pbXBvcnQgRW5jcnlwdGlvbiBmcm9tIFwiLi9lbmNyeXB0aW9uXCI7XG5cbmNvbnN0IGRlY29kZVRva2VuQ29tcG9uZW50ID0gKGJhc2U2NFVybDogc3RyaW5nKTogb2JqZWN0ID0+IHtcbiAgY29uc3QgYmFzZTY0ID0gYmFzZTY0VXJsVG9CYXNlNjRFbmNvZGVkKGJhc2U2NFVybCk7XG4gIHJldHVybiBKU09OLnBhcnNlKEJ1ZmZlci5mcm9tKGJhc2U2NCwgXCJiYXNlNjRcIikudG9TdHJpbmcoXCJiaW5hcnlcIikpO1xufTtcblxuY29uc3QgZW5jb2RlVG9rZW5Db21wb25lbnQgPSAoanNvbjogb2JqZWN0KTogc3RyaW5nID0+IHtcbiAgY29uc3QgYmFzZTY0RW5jb2RlZCA9IEJ1ZmZlci5mcm9tKEpTT04uc3RyaW5naWZ5KGpzb24pKS50b1N0cmluZyhcImJhc2U2NFwiKTtcbiAgcmV0dXJuIGJhc2U2NFRvQmFzZTY0VXJsRW5jb2RlZChiYXNlNjRFbmNvZGVkKTtcbn07XG5cbmNvbnN0IGNvbXBvc2VNZXNzYWdlID0gKGhlYWRlcjogSldUSGVhZGVyLCBwYXlsb2FkOiBKV1RQYXlsb2FkKTogc3RyaW5nID0+IHtcbiAgcmV0dXJuIGAke2VuY29kZVRva2VuQ29tcG9uZW50KGhlYWRlcil9LiR7ZW5jb2RlVG9rZW5Db21wb25lbnQocGF5bG9hZCl9YDtcbn07XG5cbmV4cG9ydCBjb25zdCBwYXJzZUp3dCA9ICh0b2tlbjogc3RyaW5nKTogSldUVHlwZSA9PiB7XG4gIGNvbnN0IFtoZWFkZXJFbmNvZGVkLCBwYXlsb2FkRW5jb2RlZCwgc2lnbmF0dXJlXSA9IHRva2VuLnNwbGl0KFwiLlwiKTtcbiAgY29uc3QgW2hlYWRlciwgcGF5bG9hZF0gPSBbaGVhZGVyRW5jb2RlZCwgcGF5bG9hZEVuY29kZWRdLm1hcChcbiAgICBkZWNvZGVUb2tlbkNvbXBvbmVudFxuICApO1xuICAvLyBAdHMtaWdub3JlXG4gIGlmICghaGVhZGVyW1wiYWxnXCJdIHx8ICFoZWFkZXJbXCJ0eXBcIl0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJIZWFkZXIgZm9ybWF0IGlzIG5vdCBjb3JyZWN0LlwiKTtcbiAgfVxuICAvLyBAdHMtaWdub3JlXG4gIHJldHVybiB7IGhlYWRlciwgaGVhZGVyRW5jb2RlZCwgcGF5bG9hZCwgcGF5bG9hZEVuY29kZWQsIHNpZ25hdHVyZSB9O1xufTtcblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSBKV1QuXG4gKiBAcGFyYW0gc2lnbmluZ1xuICogQHBhcmFtIHBheWxvYWRcbiAqL1xuZXhwb3J0IGNvbnN0IGdlbmVyYXRlSnd0ID0gKHNpZ25pbmc6IFNpZ25pbmcsIHBheWxvYWQ/OiBhbnkpOiBzdHJpbmcgPT4ge1xuICAvLyBOT1RFOiBBZGRlZCBgLSA2MGAganVzdCBpbiBjYXNlIGEgdGltZXN0YW1wIGluIHRoZSBCRSBpcyBub3Qgd29ya2luZyBwcm9wZXJseS5cbiAgY29uc3QgdGltZXN0YW1wID0gTnVtYmVyKChuZXcgRGF0ZSgpLmdldFRpbWUoKSAvIDEwMDApLnRvRml4ZWQoMCkpIC0gNjA7XG4gIGNvbnN0IGhlYWRlciA9IHtcbiAgICBhbGc6IFwiRWREU0FcIixcbiAgICB0eXA6IFwiSldUXCIsXG4gIH07XG4gIGNvbnN0IHAgPSBwYXlsb2FkIHx8IHtcbiAgICBleHA6IHRpbWVzdGFtcCArIDYwICogNjAsXG4gICAgaWF0OiB0aW1lc3RhbXAsXG4gICAgc2lnbmluZ19rZXk6IHNpZ25pbmcuZXhwb3J0UHVibGljS2V5KCksXG4gIH07XG4gIGNvbnN0IHNpZ25hdHVyZSA9IHNpZ25pbmcuc2lnbihjb21wb3NlTWVzc2FnZShoZWFkZXIsIHApLCB7IGlucHV0OiBcInV0ZjhcIiB9KTtcbiAgcmV0dXJuIGAke2VuY29kZVRva2VuQ29tcG9uZW50KGhlYWRlcil9LiR7ZW5jb2RlVG9rZW5Db21wb25lbnQoXG4gICAgcFxuICApfS4ke3NpZ25hdHVyZX1gO1xufTtcblxuLyoqXG4gKiBHZW5lcmF0ZXMgYW4gYXBwcm92YWwgdG9rZW5cbiAqIEBwYXJhbSBzaWduaW5nXG4gKiBAcGFyYW0gY2xpZW50SWRcbiAqIEBwYXJhbSBlbnRpdHlJZFxuICogQHBhcmFtIGFwcHJvdmVkU2NvcGVzXG4gKiBAcGFyYW0gb2ZmZXJDb2RlXG4gKi9cbmV4cG9ydCBjb25zdCBnZW5lcmF0ZUFwcHJvdmFsVG9rZW4gPSAoXG4gIHNpZ25pbmc6IFNpZ25pbmcsXG4gIGNsaWVudElkOiBzdHJpbmcsXG4gIGVudGl0eUlkOiBzdHJpbmcsXG4gIGFwcHJvdmVkU2NvcGVzOiBzdHJpbmdbXSxcbiAgb2ZmZXJDb2RlPzogc3RyaW5nXG4pID0+IHtcbiAgLy8gTk9URTogQWRkZWQgYC0gNjBgIGp1c3QgaW4gY2FzZSBhIHRpbWVzdGFtcCBpbiB0aGUgQkUgaXMgbm90IHdvcmtpbmcgcHJvcGVybHkuXG4gIGNvbnN0IHRpbWVzdGFtcCA9IE51bWJlcigobmV3IERhdGUoKS5nZXRUaW1lKCkgLyAxMDAwKS50b0ZpeGVkKDApKSAtIDYwO1xuICBjb25zdCBwYXlsb2FkID0ge1xuICAgIGNsaWVudF9pZDogY2xpZW50SWQsXG4gICAgaWF0OiB0aW1lc3RhbXAsXG4gICAgaXNzOiBlbnRpdHlJZCxcbiAgICBzY29wZXM6IGFwcHJvdmVkU2NvcGVzLmpvaW4oXCIgXCIpLFxuICB9O1xuICBpZiAob2ZmZXJDb2RlKSB7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHBheWxvYWRbXCJvZmZlcl9jb2RlXCJdID0gb2ZmZXJDb2RlO1xuICB9XG4gIHJldHVybiBnZW5lcmF0ZUp3dChzaWduaW5nLCBwYXlsb2FkKTtcbn07XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgY2xhaW0gdG9rZW4gYW5kIGEgY29tbWl0bWVudFxuICogQHBhcmFtIHNpZ25pbmdcbiAqIEBwYXJhbSBwcm92aWRlcklkXG4gKiBAcGFyYW0gZW50aXR5SWRcbiAqIEBwYXJhbSBzY29wZU5hbWVcbiAqIEBwYXJhbSBjbGFpbSAtIGNsYWltIG9iamVjdCB3aXRoIHJhdyB2YWx1ZXMuXG4gKiBAcmV0dXJucyB7IHRva2VuOiBzdHJpbmc7IGNvbW1pdG1lbnQ6IHN0cmluZyB9XG4gKi9cbmV4cG9ydCBjb25zdCBnZW5lcmF0ZUNsYWltVG9rZW4gPSAoXG4gIHNpZ25pbmc6IFNpZ25pbmcsXG4gIHByb3ZpZGVySWQ6IHN0cmluZyxcbiAgZW50aXR5SWQ6IHN0cmluZyxcbiAgc2NvcGVOYW1lOiBzdHJpbmcsXG4gIGNsYWltOiBvYmplY3RcbikgPT4ge1xuICAvLyBOT1RFOiBBZGRlZCBgLSA2MGAganVzdCBpbiBjYXNlIGEgdGltZXN0YW1wIGluIHRoZSBCRSBpcyBub3Qgd29ya2luZyBwcm9wZXJseS5cbiAgY29uc3QgdGltZXN0YW1wID0gTnVtYmVyKChuZXcgRGF0ZSgpLmdldFRpbWUoKSAvIDEwMDApLnRvRml4ZWQoMCkpIC0gNjA7XG4gIGNvbnN0IGNvbW1pdG1lbnQgPSBnZW5lcmF0ZUNvbW1pdG1lbnQoKTtcbiAgY29uc3Qga2V5ID0gc2NvcGVOYW1lLmluY2x1ZGVzKFwiOlwiKVxuICAgID8gYCR7c2NvcGVOYW1lfTpjb21taXRtZW50YFxuICAgIDogYCR7c2NvcGVOYW1lfV9jb21taXRtZW50YDtcbiAgY29uc3Qgc2NvcGVIYXNoID0gc2hhMjU2KFxuICAgIHVuaWZ5SnNvbkRhdGEoe1xuICAgICAgLi4uY2xhaW0sXG4gICAgICBba2V5XTogY29tbWl0bWVudCxcbiAgICB9KVxuICApO1xuICBjb25zdCBwYXlsb2FkID0ge1xuICAgIGlhdDogdGltZXN0YW1wLFxuICAgIGlzczogcHJvdmlkZXJJZCxcbiAgICB1c2VyX2lkOiBlbnRpdHlJZCxcbiAgICBzY29wZV9uYW1lOiBzY29wZU5hbWUsXG4gICAgc2NvcGVfaGFzaDogc2NvcGVIYXNoLFxuICB9O1xuICBjb25zdCB0b2tlbiA9IGdlbmVyYXRlSnd0KHNpZ25pbmcsIHBheWxvYWQpO1xuICByZXR1cm4geyB0b2tlbiwgY29tbWl0bWVudCB9O1xufTtcblxuLyoqXG4gKiBHZW5lcmF0ZSBkaXNidXJzZW1lbnQgdG9rZW5cbiAqIEBwYXJhbSBzaWduaW5nXG4gKiBAcGFyYW0gcHJvdmlkZXJJZFxuICogQHBhcmFtIGVudGl0eUlkXG4gKiBAcGFyYW0gY2xhaW1PYmpcbiAqICBmb3JtYXQ6IHsgY2xhaW1zW2tleUFdOiB7IFtkaXNidXJzZW1lbnRfa2V5XToge30sIFtjb21taXRtZW50X2tleV06IHt9IH0sIGNsYWltc1trZXlCXSAuLi4gfVxuICogQHBhcmFtIHB1YmxpY0tleVxuICogQHJldHVybnMgc3RyaW5nXG4gKi9cbmV4cG9ydCBjb25zdCBnZW5lcmF0ZURpc2J1cnNlbWVudFRva2VuID0gYXN5bmMgKFxuICBzaWduaW5nOiBTaWduaW5nLFxuICBwcm92aWRlcklkOiBzdHJpbmcsXG4gIGVudGl0eUlkOiBzdHJpbmcsXG4gIGNsYWltT2JqOiB7IFtrZXk6IHN0cmluZ106IGFueSB9LFxuICBwdWJsaWNLZXk/OiBzdHJpbmdcbikgPT4ge1xuICBsZXQgZGlzYnVyc2VtZW50Q2xhaW1Db21wb3NlT2JqOiB7IFtrZXk6IHN0cmluZ106IGFueSB9ID0ge30sXG4gICAgZW5jcnlwdGVkQ29udGVudHM6IHN0cmluZ1tdO1xuICAvLyBOT1RFOiBBZGRlZCBgLSA2MGAganVzdCBpbiBjYXNlIGEgdGltZXN0YW1wIGluIHRoZSBCRSBpcyBub3Qgd29ya2luZyBwcm9wZXJseS5cbiAgY29uc3QgdGltZXN0YW1wID0gTnVtYmVyKChuZXcgRGF0ZSgpLmdldFRpbWUoKSAvIDEwMDApLnRvRml4ZWQoMCkpIC0gNjA7XG5cbiAgaWYgKHB1YmxpY0tleSkge1xuICAgIGNvbnN0IGVuYyA9IG5ldyBFbmNyeXB0aW9uKCk7XG4gICAgaWYgKHB1YmxpY0tleS5zdGFydHNXaXRoKFwiTVwiKSkge1xuICAgICAgYXdhaXQgZW5jLmltcG9ydFB1YmxpY0tleUluQmFzZTY0VXJsKHB1YmxpY0tleSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGF3YWl0IGVuYy5pbXBvcnRQdWJsaWNLZXkocHVibGljS2V5KTtcbiAgICB9XG5cbiAgICBlbmNyeXB0ZWRDb250ZW50cyA9IGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgT2JqZWN0LmtleXMoY2xhaW1PYmopLm1hcCgoc2NvcGVLZXkpID0+IHtcbiAgICAgICAgaWYgKCFjbGFpbU9ialtzY29wZUtleV1bc2NvcGVLZXldKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGlzYnVyc2VtZW50IGNsYWltIG9iamVjdCBpcyBub3QgdmFsaWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVuYy5lbmNyeXB0U3RyaW5nVG9CYXNlNjRVcmxTdHJpbmcoXG4gICAgICAgICAgY2xhaW1PYmpbc2NvcGVLZXldW3Njb3BlS2V5XS5jb250ZW50XG4gICAgICAgICk7XG4gICAgICB9KVxuICAgICk7XG4gIH1cblxuICAvLyBUcmFuc2Zvcm0gY2xhaW0gb2JqXG4gIE9iamVjdC5rZXlzKGNsYWltT2JqKS5mb3JFYWNoKChzY29wZUtleSwgaW5kZXgpID0+IHtcbiAgICBjb25zdCBjbGFpbSA9IGNsYWltT2JqW3Njb3BlS2V5XTtcblxuICAgIGlmICghY2xhaW1bc2NvcGVLZXldKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEaXNidXJzZW1lbnQgY2xhaW0gb2JqZWN0IGlzIG5vdCB2YWxpZFwiKTtcbiAgICB9XG5cbiAgICBjb25zdCBjb250ZW50ID0gcHVibGljS2V5XG4gICAgICA/IGVuY3J5cHRlZENvbnRlbnRzW2luZGV4XVxuICAgICAgOiBjbGFpbVtzY29wZUtleV0uY29udGVudDtcblxuICAgIGRpc2J1cnNlbWVudENsYWltQ29tcG9zZU9ialtzY29wZUtleV0gPSB7XG4gICAgICBjb250ZW50X3R5cGU6IGNsYWltW3Njb3BlS2V5XS5jb250ZW50X3R5cGUsXG4gICAgICBjb250ZW50LFxuICAgIH07XG4gICAgZGlzYnVyc2VtZW50Q2xhaW1Db21wb3NlT2JqW2Ake3Njb3BlS2V5fTpjb21taXRtZW50YF0gPVxuICAgICAgY2xhaW1bYCR7c2NvcGVLZXl9OmNvbW1pdG1lbnRgXTtcbiAgfSk7XG5cbiAgLy8gQ3VycmVudCB3ZSB3aWxsIHVzZSByYXcgYmFzZTY0LCBub3QgY2hhbmdlIHRoZSBtZXRob2QgZW5jcnlwdFxuICBjb25zdCBwYXlsb2FkID0ge1xuICAgIGlhdDogdGltZXN0YW1wLFxuICAgIGlzczogcHJvdmlkZXJJZCxcbiAgICB1c2VyX2lkOiBlbnRpdHlJZCxcbiAgICAuLi5kaXNidXJzZW1lbnRDbGFpbUNvbXBvc2VPYmosXG4gIH07XG4gIGNvbnN0IHRva2VuID0gZ2VuZXJhdGVKd3Qoc2lnbmluZywgcGF5bG9hZCk7XG4gIHJldHVybiB0b2tlbjtcbn07XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgcmVxdWVzdCB0b2tlblxuICogQHBhcmFtIHNpZ25pbmdcbiAqIEBwYXJhbSBlbmNyeXB0aW9uUHVibGljS2V5IC0gQmFzZTY0IFVSTCBlbmNvZGVkIHB1YmxpYyBrZXlcbiAqIEBwYXJhbSBzY29wZXMgLSBSZXF1ZXN0ZWQgc2NvcGVzIGxpc3QuXG4gKiBAcGFyYW0gb2ZmZXJDb2RlXG4gKi9cbmV4cG9ydCBjb25zdCBnZW5lcmF0ZVJlcXVlc3RUb2tlbiA9IChcbiAgc2lnbmluZzogU2lnbmluZyxcbiAgZW5jcnlwdGlvblB1YmxpY0tleTogc3RyaW5nLFxuICBzY29wZXM6IHN0cmluZ1tdLFxuICBvZmZlckNvZGU/OiBzdHJpbmdcbikgPT4ge1xuICBpZiAoIXNjb3Blcy5pbmNsdWRlcyhcIm9wZW5pZFwiKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIm9wZW5pZCBpcyByZXF1aXJlZC5cIik7XG4gIH1cbiAgLy8gTk9URTogQWRkZWQgYC0gNjBgIGp1c3QgaW4gY2FzZSBhIHRpbWVzdGFtcCBpbiB0aGUgQkUgaXMgbm90IHdvcmtpbmcgcHJvcGVybHkuXG4gIGNvbnN0IHRpbWVzdGFtcCA9IE51bWJlcigobmV3IERhdGUoKS5nZXRUaW1lKCkgLyAxMDAwKS50b0ZpeGVkKDApKSAtIDYwO1xuICBjb25zdCBmb3JtYXR0ZWRTY29wZXMgPSBzY29wZXMuam9pbihcIiBcIik7XG4gIGNvbnN0IHBheWxvYWQgPSB7XG4gICAgZW5jcnlwdGlvbl9wdWJsaWNfa2V5OiBlbmNyeXB0aW9uUHVibGljS2V5LFxuICAgIGlhdDogdGltZXN0YW1wLFxuICAgIHNjb3BlczogZm9ybWF0dGVkU2NvcGVzLFxuICB9O1xuICBpZiAob2ZmZXJDb2RlKSB7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHBheWxvYWRbXCJvZmZlcl9jb2RlXCJdID0gb2ZmZXJDb2RlO1xuICB9XG4gIHJldHVybiBnZW5lcmF0ZUp3dChzaWduaW5nLCBwYXlsb2FkKTtcbn07XG5cbi8qKlxuICogR2VuZXJhdGVzIGFuIGlkZW50aXR5IHRva2VuXG4gKiBAcGFyYW0gc2lnbmluZ1xuICogQHBhcmFtIGVudGl0eUlkXG4gKiBAcGFyYW0gaWRlbnRpdHlTb3VyY2VcbiAqIEBwYXJhbSBpZGVudGl0eUhhc2hcbiAqL1xuZXhwb3J0IGNvbnN0IGdlbmVyYXRlSWRlbnRpdHlUb2tlbiA9IChcbiAgc2lnbmluZzogU2lnbmluZyxcbiAgZW50aXR5SWQ6IHN0cmluZyxcbiAgaWRlbnRpdHlTb3VyY2U6IHN0cmluZyxcbiAgaWRlbnRpdHlIYXNoOiBzdHJpbmdcbikgPT4ge1xuICAvLyBOT1RFOiBBZGRlZCBgLSA2MGAganVzdCBpbiBjYXNlIGEgdGltZXN0YW1wIGluIHRoZSBCRSBpcyBub3Qgd29ya2luZyBwcm9wZXJseS5cbiAgY29uc3QgdGltZXN0YW1wID0gTnVtYmVyKChuZXcgRGF0ZSgpLmdldFRpbWUoKSAvIDEwMDApLnRvRml4ZWQoMCkpIC0gNjA7XG4gIGNvbnN0IHBheWxvYWQgPSB7XG4gICAgaWF0OiB0aW1lc3RhbXAsXG4gICAgaXNzOiBlbnRpdHlJZCxcbiAgICBpZGVudGl0eV9zb3VyY2U6IGlkZW50aXR5U291cmNlLFxuICAgIGlkZW50aXR5X2hhc2g6IGlkZW50aXR5SGFzaCxcbiAgfTtcbiAgcmV0dXJuIGdlbmVyYXRlSnd0KHNpZ25pbmcsIHBheWxvYWQpO1xufTtcblxuZXhwb3J0IGNvbnN0IHZlcmlmeUp3dCA9IChqd3Q6IEpXVFR5cGUsIHNpZ25pbmc6IFNpZ25pbmcpOiBib29sZWFuID0+IHtcbiAgY29uc3QgbWVzc2FnZSA9IGAke2p3dC5oZWFkZXJFbmNvZGVkfS4ke2p3dC5wYXlsb2FkRW5jb2RlZH1gO1xuICByZXR1cm4gc2lnbmluZy52ZXJpZnkobWVzc2FnZSwgand0LnNpZ25hdHVyZSk7XG59O1xuIiwiLy8gQHRzLWlnbm9yZVxuaW1wb3J0ICogYXMgSERLZXkgZnJvbSBcImhka2V5XCI7XG5pbXBvcnQgKiBhcyBiaXAzOSBmcm9tIFwiYmlwMzlcIjtcbmltcG9ydCAqIGFzIHdpZiBmcm9tIFwid2lmXCI7XG5pbXBvcnQgKiBhcyBlbGxpcHRpYyBmcm9tIFwiZWxsaXB0aWNcIjtcbmltcG9ydCB7IFByaXZhdGVLZXksIFB1YmxpY0tleSB9IGZyb20gXCJlb3Nqcy9kaXN0L2Vvc2pzLWpzc2lnXCI7XG5pbXBvcnQge1xuICBiYXNlNjRUb0JpbmFyeSxcbiAgYmluYXJ5VG9CYXNlNTgsXG4gIEtleVR5cGUsXG4gIHB1YmxpY0tleURhdGFTaXplLFxuICBzdHJpbmdUb1B1YmxpY0tleSxcbn0gZnJvbSBcImVvc2pzL2Rpc3QvZW9zanMtbnVtZXJpY1wiO1xuaW1wb3J0IHR5cGUgeyBDb2luVHlwZSwgV2FsbGV0IGFzIElXYWxsZXQgfSBmcm9tIFwiLi4vdHlwZXNcIjtcblxuY29uc3QgcmlwZW1kMTYwID0gcmVxdWlyZShcImVvc2pzL2Rpc3QvcmlwZW1kXCIpLlJJUEVNRDE2MC5oYXNoIGFzIChcbiAgYTogVWludDhBcnJheVxuKSA9PiBBcnJheUJ1ZmZlcjtcbmNvbnN0IGVjZHNhID0gbmV3IGVsbGlwdGljLmVjKFwic2VjcDI1NmsxXCIpO1xuXG5jbGFzcyBXYWxsZXQgaW1wbGVtZW50cyBJV2FsbGV0IHtcbiAgcHJpdmF0ZSByZWFkb25seSBtbmVtb25pYzogc3RyaW5nO1xuICBwcml2YXRlIG1hc3Rlck5vZGU6IEhES2V5O1xuXG4gIHB1YmxpYyBjb25zdHJ1Y3RvcihtbmVtb25pYzogc3RyaW5nKSB7XG4gICAgaWYgKG1uZW1vbmljLnNwbGl0KFwiIFwiKS5sZW5ndGggIT09IDEyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNbmVtb25pYyBmb3JtYXQgaXMgbm90IGNvcnJlY3RcIik7XG4gICAgfVxuICAgIHRoaXMubW5lbW9uaWMgPSBtbmVtb25pYztcbiAgICBjb25zdCBzZWVkOiBCdWZmZXIgPSBiaXAzOS5tbmVtb25pY1RvU2VlZFN5bmModGhpcy5tbmVtb25pYyk7XG4gICAgdGhpcy5tYXN0ZXJOb2RlID0gSERLZXkuZnJvbU1hc3RlclNlZWQoc2VlZCk7XG4gIH1cblxuICBwdWJsaWMgc3RhdGljIGNyZWF0ZSgpOiBXYWxsZXQge1xuICAgIGNvbnN0IG0gPSBiaXAzOS5nZW5lcmF0ZU1uZW1vbmljKCk7XG4gICAgcmV0dXJuIG5ldyBXYWxsZXQobSk7XG4gIH1cblxuICBwdWJsaWMgZ2V0TW5lbW9uaWMoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5tbmVtb25pYztcbiAgfVxuXG4gIHB1YmxpYyBnZXRNYXN0ZXJQcml2YXRlS2V5KCk6IHN0cmluZyB7XG4gICAgY29uc3QgbWFzdGVyUHJpdmF0ZUtleSA9IHdpZi5lbmNvZGUoMTI4LCB0aGlzLm1hc3Rlck5vZGUucHJpdmF0ZUtleSwgdHJ1ZSk7XG4gICAgLy8gY29uc29sZS5sb2coYD09PiBnZXRNYXN0ZXJQcml2YXRlS2V5IDogJHttYXN0ZXJQcml2YXRlS2V5fWApO1xuICAgIHJldHVybiBtYXN0ZXJQcml2YXRlS2V5O1xuICB9XG5cbiAgcHVibGljIGdldE1hc3RlclB1YmxpY0tleSgpOiBzdHJpbmcge1xuICAgIGNvbnN0IG1hc3RlclB1YmxpY0tleSA9IHRoaXMubWFzdGVyTm9kZS5wdWJsaWNLZXkudG9TdHJpbmcoXCJoZXhcIik7XG4gICAgLy8gY29uc29sZS5sb2coYD09PiBnZXRNYXN0ZXJQdWJsaWNLZXkgOiAke21hc3RlclB1YmxpY0tleX1gKTtcbiAgICByZXR1cm4gbWFzdGVyUHVibGljS2V5O1xuICB9XG5cbiAgcHVibGljIGdldEVPU1ByaXZhdGVLZXkoKTogc3RyaW5nIHtcbiAgICBjb25zdCBjaGlsZE5vZGUgPSB0aGlzLm1hc3Rlck5vZGUuZGVyaXZlKHRoaXMuZ2V0Q29pbktleShcIkVPU1wiKSk7XG4gICAgY29uc3QgZWxsaXB0aWNLZXlQYWlyID0gZWNkc2Eua2V5RnJvbVByaXZhdGUoY2hpbGROb2RlLnByaXZhdGVLZXkpO1xuICAgIGNvbnN0IGVvc1ByaXZhdGVLZXkgPSBQcml2YXRlS2V5LmZyb21FbGxpcHRpYyhcbiAgICAgIGVsbGlwdGljS2V5UGFpcixcbiAgICAgIEtleVR5cGUuazEsXG4gICAgICBlY2RzYVxuICAgICk7XG4gICAgcmV0dXJuIGVvc1ByaXZhdGVLZXkudG9MZWdhY3lTdHJpbmcoKTtcbiAgfVxuXG4gIHB1YmxpYyBnZXRFT1NQdWJsaWNLZXkoKTogc3RyaW5nIHtcbiAgICBjb25zdCBjaGlsZE5vZGUgPSB0aGlzLm1hc3Rlck5vZGUuZGVyaXZlKHRoaXMuZ2V0Q29pbktleShcIkVPU1wiKSk7XG4gICAgY29uc3QgZWxsaXB0aWNLZXlQYWlyID0gZWNkc2Eua2V5RnJvbVByaXZhdGUoY2hpbGROb2RlLnByaXZhdGVLZXkpO1xuICAgIGNvbnN0IGVvc1B1YmxpY0tleSA9IFB1YmxpY0tleS5mcm9tRWxsaXB0aWMoXG4gICAgICBlbGxpcHRpY0tleVBhaXIsXG4gICAgICBLZXlUeXBlLmsxLFxuICAgICAgZWNkc2FcbiAgICApO1xuICAgIHJldHVybiB0aGlzLmNvbnZlcnRUb0Vvc0xlZ2FjeVB1YmxpY0tleShlb3NQdWJsaWNLZXkpO1xuICB9XG5cbiAgcHJpdmF0ZSBnZXRDb2luS2V5KGNvaW5UeXBlOiBDb2luVHlwZSk6IHN0cmluZyB7XG4gICAgc3dpdGNoIChjb2luVHlwZSkge1xuICAgICAgY2FzZSBcIkJUQ1wiOiB7XG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgfVxuICAgICAgY2FzZSBcIkVPU1wiOiB7XG4gICAgICAgIHJldHVybiAnbS80NFxcJy8xOTRcXCcvMFxcJy8wLzAnO1xuICAgICAgfVxuICAgICAgY2FzZSBcIkVUSFwiOiB7XG4gICAgICAgIHJldHVybiAnbS80NFxcJy82MFxcJy8xXFwnLzAvMCc7XG4gICAgICB9XG4gICAgICBjYXNlIFwiWFJQXCI6IHtcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBjb252ZXJ0VG9Fb3NMZWdhY3lQdWJsaWNLZXkocHVibGljS2V5OiBQdWJsaWNLZXkpOiBzdHJpbmcge1xuICAgIGNvbnN0IGtleVN0cmluZyA9IHB1YmxpY0tleS50b1N0cmluZygpO1xuICAgIGNvbnN0IGtleSA9IHN0cmluZ1RvUHVibGljS2V5KGtleVN0cmluZyk7XG4gICAgaWYgKGtleS50eXBlID09IEtleVR5cGUuazEgJiYga2V5LmRhdGEubGVuZ3RoID09PSBwdWJsaWNLZXlEYXRhU2l6ZSkge1xuICAgICAgY29uc3QgZGlnZXN0ID0gbmV3IFVpbnQ4QXJyYXkocmlwZW1kMTYwKGtleS5kYXRhKSk7XG4gICAgICBjb25zdCB3aG9sZSA9IG5ldyBVaW50OEFycmF5KHB1YmxpY0tleURhdGFTaXplICsgNCk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHB1YmxpY0tleURhdGFTaXplOyArK2kpIHdob2xlW2ldID0ga2V5LmRhdGFbaV07XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDQ7ICsraSkgd2hvbGVbaSArIHB1YmxpY0tleURhdGFTaXplXSA9IGRpZ2VzdFtpXTtcbiAgICAgIHJldHVybiBcIkVPU1wiICsgYmluYXJ5VG9CYXNlNTgod2hvbGUpO1xuICAgIH0gZWxzZSBpZiAoa2V5LnR5cGUgPT0gS2V5VHlwZS5yMSAmJiBrZXkuZGF0YS5sZW5ndGggPT09IHB1YmxpY0tleURhdGFTaXplKSB7XG4gICAgICByZXR1cm4ga2V5U3RyaW5nO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bnJlY29nbml6ZWQgcHVibGljIGtleSBmb3JtYXRcIik7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFdhbGxldDtcbiIsImltcG9ydCBFbmNyeXB0aW9uIGZyb20gXCIuL2VuY3J5cHRpb25cIjtcbmltcG9ydCBTaWduaW5nIGZyb20gXCIuL3NpZ25pbmdcIjtcbmltcG9ydCB7XG4gIGdlbmVyYXRlSnd0LFxuICBwYXJzZUp3dCxcbiAgdmVyaWZ5Snd0LFxuICBnZW5lcmF0ZUlkZW50aXR5VG9rZW4sXG4gIGdlbmVyYXRlQ2xhaW1Ub2tlbixcbiAgZ2VuZXJhdGVSZXF1ZXN0VG9rZW4sXG4gIGdlbmVyYXRlQXBwcm92YWxUb2tlbixcbiAgZ2VuZXJhdGVEaXNidXJzZW1lbnRUb2tlbixcbn0gZnJvbSBcIi4vand0XCI7XG5pbXBvcnQge1xuICBzaGEyNTYsXG4gIGdlbmVyYXRlQ29tbWl0bWVudCxcbiAgYmFzZTY0VXJsVG9CdWZmZXIsXG4gIGJhc2U2NFRvQmFzZTY0VXJsRW5jb2RlZCxcbiAgYmFzZTY0VXJsVG9CYXNlNjRFbmNvZGVkLFxuICBidWZmZXJUb0Jhc2U2NFVybEVuY29kZWQsXG4gIHNoYTI1NkJ5RWFjaEZpZWxkLFxuICBjYW1lbGl6ZSxcbiAgZGVjYW1lbGl6ZSxcbiAgdW5pZnlKc29uRGF0YSxcbn0gZnJvbSBcIi4vdXRpbHNcIjtcbmltcG9ydCBXYWxsZXQgZnJvbSBcIi4vd2FsbGV0XCI7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgRW5jcnlwdGlvbixcbiAgU2lnbmluZyxcbiAgZ2VuZXJhdGVKd3QsXG4gIHBhcnNlSnd0LFxuICB2ZXJpZnlKd3QsXG4gIGdlbmVyYXRlUmVxdWVzdFRva2VuLFxuICBnZW5lcmF0ZUFwcHJvdmFsVG9rZW4sXG4gIGdlbmVyYXRlSWRlbnRpdHlUb2tlbixcbiAgZ2VuZXJhdGVDbGFpbVRva2VuLFxuICBnZW5lcmF0ZURpc2J1cnNlbWVudFRva2VuLFxuICBzaGEyNTYsXG4gIGdlbmVyYXRlQ29tbWl0bWVudCxcbiAgYmFzZTY0VXJsVG9CdWZmZXIsXG4gIGJhc2U2NFRvQmFzZTY0VXJsRW5jb2RlZCxcbiAgYmFzZTY0VXJsVG9CYXNlNjRFbmNvZGVkLFxuICBidWZmZXJUb0Jhc2U2NFVybEVuY29kZWQsXG4gIHNoYTI1NkJ5RWFjaEZpZWxkLFxuICBjYW1lbGl6ZSxcbiAgZGVjYW1lbGl6ZSxcbiAgdW5pZnlKc29uRGF0YSxcbiAgV2FsbGV0LFxufTtcbiJdLCJuYW1lcyI6WyJfX2Fzc2lnbiIsIk9iamVjdCIsImFzc2lnbiIsInQiLCJzIiwiaSIsIm4iLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJwIiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiYXBwbHkiLCJfX2F3YWl0ZXIiLCJ0aGlzQXJnIiwiX2FyZ3VtZW50cyIsIlAiLCJnZW5lcmF0b3IiLCJhZG9wdCIsInZhbHVlIiwicmVzb2x2ZSIsIlByb21pc2UiLCJyZWplY3QiLCJmdWxmaWxsZWQiLCJzdGVwIiwibmV4dCIsImUiLCJyZWplY3RlZCIsInJlc3VsdCIsImRvbmUiLCJ0aGVuIiwiX19nZW5lcmF0b3IiLCJib2R5IiwiXyIsImxhYmVsIiwic2VudCIsInRyeXMiLCJvcHMiLCJmIiwieSIsImciLCJ2ZXJiIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJ2Iiwib3AiLCJUeXBlRXJyb3IiLCJwb3AiLCJwdXNoIiwiY3JlYXRlSGFzaCIsInJhbmRvbUJ5dGVzIiwid2ViY3J5cHRvLkNyeXB0byIsImRlY29tcG9zZVByaXZhdGVLZXkiLCJjb21wb3NlUHJpdmF0ZUtleSIsInBraSIsImRlY29tcG9zZVB1YmxpY0tleSIsImNvbXBvc2VQdWJsaWNLZXkiLCJlbGxpcHRpYy5lYyIsImJpcDM5Lm1uZW1vbmljVG9TZWVkU3luYyIsIkhES2V5LmZyb21NYXN0ZXJTZWVkIiwiYmlwMzkuZ2VuZXJhdGVNbmVtb25pYyIsIndpZi5lbmNvZGUiLCJQcml2YXRlS2V5IiwiS2V5VHlwZSIsIlB1YmxpY0tleSIsInN0cmluZ1RvUHVibGljS2V5IiwicHVibGljS2V5RGF0YVNpemUiLCJiaW5hcnlUb0Jhc2U1OCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBK0JPLElBQUlBLE9BQVEsR0FBRyxvQkFBVztBQUM3QkEsRUFBQUEsT0FBUSxHQUFHQyxNQUFNLENBQUNDLE1BQVAsSUFBaUIsU0FBU0YsUUFBVCxDQUFrQkcsQ0FBbEIsRUFBcUI7QUFDN0MsU0FBSyxJQUFJQyxDQUFKLEVBQU9DLENBQUMsR0FBRyxDQUFYLEVBQWNDLENBQUMsR0FBR0MsU0FBUyxDQUFDQyxNQUFqQyxFQUF5Q0gsQ0FBQyxHQUFHQyxDQUE3QyxFQUFnREQsQ0FBQyxFQUFqRCxFQUFxRDtBQUNqREQsTUFBQUEsQ0FBQyxHQUFHRyxTQUFTLENBQUNGLENBQUQsQ0FBYjs7QUFDQSxXQUFLLElBQUlJLENBQVQsSUFBY0wsQ0FBZDtBQUFpQixZQUFJSCxNQUFNLENBQUNTLFNBQVAsQ0FBaUJDLGNBQWpCLENBQWdDQyxJQUFoQyxDQUFxQ1IsQ0FBckMsRUFBd0NLLENBQXhDLENBQUosRUFBZ0ROLENBQUMsQ0FBQ00sQ0FBRCxDQUFELEdBQU9MLENBQUMsQ0FBQ0ssQ0FBRCxDQUFSO0FBQWpFO0FBQ0g7O0FBQ0QsV0FBT04sQ0FBUDtBQUNILEdBTkQ7O0FBT0EsU0FBT0gsT0FBUSxDQUFDYSxLQUFULENBQWUsSUFBZixFQUFxQk4sU0FBckIsQ0FBUDtBQUNILENBVE07QUFzQ0EsU0FBU08sU0FBVCxDQUFtQkMsT0FBbkIsRUFBNEJDLFVBQTVCLEVBQXdDQyxDQUF4QyxFQUEyQ0MsU0FBM0MsRUFBc0Q7QUFDekQsV0FBU0MsS0FBVCxDQUFlQyxLQUFmLEVBQXNCO0FBQUUsV0FBT0EsS0FBSyxZQUFZSCxDQUFqQixHQUFxQkcsS0FBckIsR0FBNkIsSUFBSUgsQ0FBSixDQUFNLFVBQVVJLE9BQVYsRUFBbUI7QUFBRUEsTUFBQUEsT0FBTyxDQUFDRCxLQUFELENBQVA7QUFBaUIsS0FBNUMsQ0FBcEM7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
