/*!
  credify-crypto.js v1.4.4
  https://developers.credify.one
  Released under the MIT License.
*/
import { Crypto } from '@peculiar/webcrypto';
import { decomposePrivateKey, composePrivateKey, decomposePublicKey, composePublicKey } from '@credify/crypto-key-composer';
import { createHash, randomBytes } from 'crypto';
import { pki } from 'node-forge';
import { fromMasterSeed } from 'hdkey';
import { mnemonicToSeedSync, generateMnemonic } from 'bip39';
import { encode } from 'wif';
import { ec } from 'elliptic';
import { PrivateKey, PublicKey } from 'eosjs/dist/eosjs-jssig';
import { KeyType, stringToPublicKey, publicKeyDataSize, binaryToBase58 } from 'eosjs/dist/eosjs-numeric';

var _assign = function __assign() {
  _assign = Object.assign || function __assign(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];

      for (var p in s) {
        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
      }
    }

    return t;
  };

  return _assign.apply(this, arguments);
};
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }

  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _ = {
    label: 0,
    sent: function sent() {
      if (t[0] & 1) throw t[1];
      return t[1];
    },
    trys: [],
    ops: []
  },
      f,
      y,
      t,
      g;
  return g = {
    next: verb(0),
    "throw": verb(1),
    "return": verb(2)
  }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
    return this;
  }), g;

  function verb(n) {
    return function (v) {
      return step([n, v]);
    };
  }

  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");

    while (_) {
      try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
        if (y = 0, t) op = [op[0] & 2, t.value];

        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;

          case 4:
            _.label++;
            return {
              value: op[1],
              done: false
            };

          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;

          case 7:
            op = _.ops.pop();

            _.trys.pop();

            continue;

          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }

            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }

            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }

            if (t && _.label < t[2]) {
              _.label = t[2];

              _.ops.push(op);

              break;
            }

            if (t[2]) _.ops.pop();

            _.trys.pop();

            continue;
        }

        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
    }

    if (op[0] & 5) throw op[1];
    return {
      value: op[0] ? op[1] : void 0,
      done: true
    };
  }
}

var headerPrivateKey = "-----BEGIN PRIVATE KEY-----\n";
var footerPrivateKey = "\n-----END PRIVATE KEY-----";
var headerPublicKey = "-----BEGIN PUBLIC KEY-----\n";
var footerPublicKey = "\n-----END PUBLIC KEY-----";
var isArray = function (a) {
    return Array.isArray(a);
};
var isObject = function (o) {
    return o === Object(o) && !isArray(o) && typeof o !== "function";
};
var sha256 = function (value) {
    if (isObject(value) || isArray(value)) {
        var base64_1 = createHash("sha256")
            .update(JSON.stringify(value))
            .digest("base64");
        return base64ToBase64UrlEncoded(base64_1);
    }
    var base64 = createHash("sha256").update(value).digest("base64");
    return base64ToBase64UrlEncoded(base64);
};
var generateCommitment = function (bytes) {
    var b = bytes || 32;
    return base64ToBase64UrlEncoded(randomBytes(b).toString("base64"));
};
var extractBuffer = function (pemString, type) {
    if (type === "public") {
        var formattedPublicKeyPem = pemString.startsWith(headerPublicKey)
            ? pemString.split(headerPublicKey)[1]
            : pemString;
        formattedPublicKeyPem = formattedPublicKeyPem.endsWith(footerPublicKey)
            ? formattedPublicKeyPem.split(footerPublicKey)[0]
            : formattedPublicKeyPem;
        return Buffer.from(formattedPublicKeyPem.replace(/\r/g, ""), "base64");
    }
    else {
        var formattedPrivateKeyPem = pemString.startsWith(headerPrivateKey)
            ? pemString.split(headerPrivateKey)[1]
            : pemString;
        formattedPrivateKeyPem = formattedPrivateKeyPem.endsWith(footerPrivateKey)
            ? formattedPrivateKeyPem.split(footerPrivateKey)[0]
            : formattedPrivateKeyPem;
        return Buffer.from(formattedPrivateKeyPem.replace(/\r/g, ""), "base64");
    }
};
var pemFormat = function (buffer, type) {
    if (type === "public") {
        var base64 = buffer.toString("base64");
        if (base64.includes("\n")) {
            return "" + headerPublicKey + base64 + footerPublicKey;
        }
        else {
            // @ts-ignore
            var key = base64.match(/.{1,64}/g).join("\n");
            return "" + headerPublicKey + key + footerPublicKey;
        }
    }
    else {
        var base64 = buffer.toString("base64");
        if (base64.includes("\n")) {
            return "" + headerPrivateKey + base64 + footerPrivateKey;
        }
        else {
            // @ts-ignore
            var key = base64.match(/.{1,64}/g).join("\n");
            return "" + headerPrivateKey + key + footerPrivateKey;
        }
    }
};
var bufferToBase64UrlEncoded = function (buffer) {
    var base64 = buffer.toString("base64");
    return base64ToBase64UrlEncoded(base64);
};
var base64ToBase64UrlEncoded = function (base64) {
    return base64.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
};
var base64UrlToBase64Encoded = function (base64Url) {
    return padString(base64Url).replace(/\-/g, "+").replace(/_/g, "/");
};
var base64UrlToBuffer = function (base64Url) {
    var base64 = base64UrlToBase64Encoded(base64Url);
    return Buffer.from(base64, "base64");
};
var sha256ByEachField = function (o) {
    if (isObject(o)) {
        var n_1 = {};
        Object.keys(o).forEach(function (k) {
            if (k === "verified") {
                // Ignore `verified` flag
                // @ts-ignore
                n_1[k] = o[k];
                // @ts-ignore
            }
            else if (o[k] === "" || o[k] === null) {
                // Ignore empty values
                // @ts-ignore
                n_1[k] = o[k];
            }
            else {
                // @ts-ignore
                n_1[k] = sha256ByEachField(o[k]);
            }
        });
        return n_1;
    }
    if (isArray(o)) {
        // @ts-ignore
        return o.map(function (i) { return sha256ByEachField(i); });
    }
    return sha256(o);
};
var padString = function (input) {
    var segmentLength = 4;
    var stringLength = input.length;
    var diff = stringLength % segmentLength;
    if (!diff) {
        return input;
    }
    var position = stringLength;
    var padLength = segmentLength - diff;
    var paddedStringLength = stringLength + padLength;
    var buffer = Buffer.alloc(paddedStringLength);
    buffer.write(input);
    while (padLength--) {
        buffer.write("=", position++);
    }
    return buffer.toString();
};
/**
 * Unify the Json data
 * @param data - can be any type
 * Return the ordered json object
 */
var unifyJsonData = function (unorderedObject) {
    if (!unorderedObject) {
        return unorderedObject;
    }
    if (typeof unorderedObject !== "object") {
        return unorderedObject;
    }
    return Object.keys(unorderedObject)
        .sort()
        .reduce(function (res, key) {
        if (Array.isArray(unorderedObject[key])) {
            // @ts-ignore
            res[key] = unorderedObject[key].map(unifyJsonData);
        }
        else if (typeof unorderedObject[key] === "object") {
            // @ts-ignore
            res[key] = unifyJsonData(unorderedObject[key]);
        }
        else {
            // @ts-ignore
            res[key] = unorderedObject[key];
        }
        return res;
    }, {});
};
var toCamel = function (s) {
    return s.replace(/([-_][a-z])/gi, function ($1) {
        return $1.toUpperCase().replace("-", "").replace("_", "");
    });
};
var toSnake = function (s) {
    var result = s.replace(/([A-Z])/g, " $1");
    return result.split(" ").join("_").toLowerCase();
};
var camelize = function (o) {
    if (isObject(o)) {
        var n_2 = {};
        Object.keys(o).forEach(function (k) {
            // @ts-ignore
            n_2[toCamel(k)] = camelize(o[k]);
        });
        return n_2;
    }
    else if (isArray(o)) {
        return o.map(function (i) {
            return camelize(i);
        });
    }
    return o;
};
var decamelize = function (o) {
    if (isObject(o)) {
        var n_3 = {};
        Object.keys(o).forEach(function (k) {
            // @ts-ignore
            n_3[toSnake(k)] = decamelize(o[k]);
        });
        return n_3;
    }
    else if (isArray(o)) {
        return o.map(function (i) {
            return decamelize(i);
        });
    }
    return o;
};

var DEFAULT_KEY_SIZE = 3072;
var Encryption = /** @class */ (function () {
    function Encryption() {
        var checkIsBrowser = new Function("try {return this===window;}catch(e){ return false;}");
        var isBrowser = checkIsBrowser();
        if (isBrowser) {
            this._crypto = crypto;
        }
        else {
            this._crypto = new Crypto();
        }
    }
    Object.defineProperty(Encryption.prototype, "privateKey", {
        get: function () {
            return this._privateKey;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Encryption.prototype, "publicKey", {
        get: function () {
            return this._publicKey;
        },
        enumerable: false,
        configurable: true
    });
    Encryption.prototype.generateKeyPair = function (keySize) {
        if (keySize === void 0) { keySize = DEFAULT_KEY_SIZE; }
        return __awaiter(this, void 0, void 0, function () {
            var keys;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this._crypto.subtle.generateKey({
                            name: "RSA-OAEP",
                            hash: "SHA-256",
                            publicExponent: new Uint8Array([1, 0, 1]),
                            modulusLength: keySize,
                        }, true, ["encrypt", "decrypt"])];
                    case 1:
                        keys = _a.sent();
                        this._privateKey = keys.privateKey;
                        this._publicKey = keys.publicKey;
                        return [2 /*return*/];
                }
            });
        });
    };
    Encryption.prototype.importPrivateKey = function (pem, password) {
        return __awaiter(this, void 0, void 0, function () {
            var rawPem, decomposedKey, buffer, key;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        rawPem = pem;
                        if (password) {
                            decomposedKey = decomposePrivateKey("\n" + pem + "\n", {
                                password: password,
                                format: "pkcs8-pem",
                            });
                            // Remove unnecessary property
                            delete decomposedKey["encryptionAlgorithm"];
                            rawPem = composePrivateKey(decomposedKey).replace(/\n$/, "");
                        }
                        buffer = extractBuffer(rawPem, "private");
                        return [4 /*yield*/, this._crypto.subtle.importKey("pkcs8", buffer, {
                                name: "RSA-OAEP",
                                hash: "SHA-256",
                            }, true, ["decrypt"])];
                    case 1:
                        key = _a.sent();
                        this._privateKey = key;
                        return [2 /*return*/];
                }
            });
        });
    };
    Encryption.prototype.importPrivateKeyInBase64Url = function (pem, password) {
        return __awaiter(this, void 0, void 0, function () {
            var rawPem, buffer, key;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        rawPem = base64UrlToBase64Encoded(pem);
                        rawPem = pemFormat(Buffer.from(rawPem, "base64"), "private");
                        if (password) {
                            throw new Error("Password decryption is not supported yet.");
                            // const decomposedKey = decomposePrivateKey(`\n${pem}\n`, { password, format: "pkcs8-pem" });
                            // Remove unnecessary property
                            // delete decomposedKey["encryptionAlgorithm"];
                            // rawPem = composePrivateKey(decomposedKey);
                        }
                        buffer = extractBuffer(rawPem, "private");
                        return [4 /*yield*/, this._crypto.subtle.importKey("pkcs8", buffer, {
                                name: "RSA-OAEP",
                                hash: "SHA-256",
                            }, true, ["decrypt"])];
                    case 1:
                        key = _a.sent();
                        this._privateKey = key;
                        return [2 /*return*/];
                }
            });
        });
    };
    Encryption.prototype.importPublicKey = function (pem) {
        return __awaiter(this, void 0, void 0, function () {
            var buffer, key;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        buffer = extractBuffer(pem, "public");
                        return [4 /*yield*/, this._crypto.subtle.importKey("spki", buffer, {
                                name: "RSA-OAEP",
                                hash: "SHA-256",
                            }, true, ["encrypt"])];
                    case 1:
                        key = _a.sent();
                        this._publicKey = key;
                        return [2 /*return*/];
                }
            });
        });
    };
    Encryption.prototype.importPublicKeyInBase64Url = function (pem) {
        return __awaiter(this, void 0, void 0, function () {
            var base64, buffer, key;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        base64 = base64UrlToBase64Encoded(pem);
                        buffer = Buffer.from(base64, "base64");
                        return [4 /*yield*/, this._crypto.subtle.importKey("spki", buffer, {
                                name: "RSA-OAEP",
                                hash: "SHA-256",
                            }, true, ["encrypt"])];
                    case 1:
                        key = _a.sent();
                        this._publicKey = key;
                        return [2 /*return*/];
                }
            });
        });
    };
    Encryption.prototype.encrypt = function (data) {
        return __awaiter(this, void 0, void 0, function () {
            var enc;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!this._publicKey) {
                            throw new Error("public key is not passed properly.");
                        }
                        return [4 /*yield*/, this._crypto.subtle.encrypt("RSA-OAEP", this._publicKey, data)];
                    case 1:
                        enc = _a.sent();
                        return [2 /*return*/, Buffer.from(new Uint8Array(enc))];
                }
            });
        });
    };
    Encryption.prototype.encryptStringToBase64UrlString = function (message) {
        return __awaiter(this, void 0, void 0, function () {
            var enc;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!this._publicKey) {
                            throw new Error("public key is not passed properly.");
                        }
                        return [4 /*yield*/, this.rsaLargeMessageEncrypt(message)];
                    case 1:
                        enc = _a.sent();
                        return [2 /*return*/, bufferToBase64UrlEncoded(enc)];
                }
            });
        });
    };
    Encryption.prototype.encryptFieldByField = function (plain) {
        return __awaiter(this, void 0, void 0, function () {
            var n, keys, _i, keys_1, k, _a, _b, n, _c, plain_1, i, d;
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        if (!isObject(plain)) return [3 /*break*/, 5];
                        n = {};
                        keys = Object.keys(plain);
                        _i = 0, keys_1 = keys;
                        _d.label = 1;
                    case 1:
                        if (!(_i < keys_1.length)) return [3 /*break*/, 4];
                        k = keys_1[_i];
                        // @ts-ignore
                        _a = n;
                        _b = k;
                        return [4 /*yield*/, this.encryptFieldByField(plain[k])];
                    case 2:
                        // @ts-ignore
                        _a[_b] = _d.sent();
                        _d.label = 3;
                    case 3:
                        _i++;
                        return [3 /*break*/, 1];
                    case 4: return [2 /*return*/, n];
                    case 5:
                        if (!isArray(plain)) return [3 /*break*/, 10];
                        n = [];
                        _c = 0, plain_1 = plain;
                        _d.label = 6;
                    case 6:
                        if (!(_c < plain_1.length)) return [3 /*break*/, 9];
                        i = plain_1[_c];
                        return [4 /*yield*/, this.encryptFieldByField(i)];
                    case 7:
                        d = _d.sent();
                        n.push(d);
                        _d.label = 8;
                    case 8:
                        _c++;
                        return [3 /*break*/, 6];
                    case 9: return [2 /*return*/, n];
                    case 10:
                        if (plain === null) {
                            return [2 /*return*/, null];
                        }
                        if (plain === "") {
                            return [2 /*return*/, ""];
                        }
                        if (plain === true) {
                            return [2 /*return*/, true];
                        }
                        if (plain === false) {
                            return [2 /*return*/, false];
                        }
                        return [4 /*yield*/, this.encryptStringToBase64UrlString(plain)];
                    case 11: return [2 /*return*/, _d.sent()];
                }
            });
        });
    };
    Encryption.prototype.decrypt = function (cipher) {
        return __awaiter(this, void 0, void 0, function () {
            var dec;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!this._privateKey) {
                            throw new Error("private key is not passed properly.");
                        }
                        return [4 /*yield*/, this._crypto.subtle.decrypt("RSA-OAEP", this._privateKey, cipher)];
                    case 1:
                        dec = _a.sent();
                        return [2 /*return*/, Buffer.from(dec).toString("utf8")];
                }
            });
        });
    };
    Encryption.prototype.decryptBase64UrlStringToString = function (cipher) {
        return __awaiter(this, void 0, void 0, function () {
            var base64;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        base64 = base64UrlToBase64Encoded(cipher);
                        return [4 /*yield*/, this.rsaLargeMessageDecrypt(Buffer.from(base64, "base64"))];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    Encryption.prototype.decryptFieldByField = function (cipher) {
        return __awaiter(this, void 0, void 0, function () {
            var n, keys, _i, keys_2, k, _a, _b, n, _c, cipher_1, i, d;
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        if (!isObject(cipher)) return [3 /*break*/, 5];
                        n = {};
                        keys = Object.keys(cipher);
                        _i = 0, keys_2 = keys;
                        _d.label = 1;
                    case 1:
                        if (!(_i < keys_2.length)) return [3 /*break*/, 4];
                        k = keys_2[_i];
                        // @ts-ignore
                        _a = n;
                        _b = k;
                        return [4 /*yield*/, this.decryptFieldByField(cipher[k])];
                    case 2:
                        // @ts-ignore
                        _a[_b] = _d.sent();
                        _d.label = 3;
                    case 3:
                        _i++;
                        return [3 /*break*/, 1];
                    case 4: return [2 /*return*/, n];
                    case 5:
                        if (!isArray(cipher)) return [3 /*break*/, 10];
                        n = [];
                        _c = 0, cipher_1 = cipher;
                        _d.label = 6;
                    case 6:
                        if (!(_c < cipher_1.length)) return [3 /*break*/, 9];
                        i = cipher_1[_c];
                        return [4 /*yield*/, this.decryptFieldByField(i)];
                    case 7:
                        d = _d.sent();
                        n.push(d);
                        _d.label = 8;
                    case 8:
                        _c++;
                        return [3 /*break*/, 6];
                    case 9: return [2 /*return*/, n];
                    case 10:
                        if (cipher === null) {
                            return [2 /*return*/, null];
                        }
                        if (cipher === "") {
                            return [2 /*return*/, ""];
                        }
                        if (cipher === true) {
                            return [2 /*return*/, true];
                        }
                        if (cipher === false) {
                            return [2 /*return*/, false];
                        }
                        return [4 /*yield*/, this.decryptBase64UrlStringToString(cipher)];
                    case 11: return [2 /*return*/, _d.sent()];
                }
            });
        });
    };
    Encryption.prototype.exportPrivateKey = function (password) {
        return __awaiter(this, void 0, void 0, function () {
            var data, rawPem, decomposedKey;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!this._privateKey) {
                            throw new Error("private key is not instantiated.");
                        }
                        return [4 /*yield*/, this._crypto.subtle.exportKey("pkcs8", this._privateKey)];
                    case 1:
                        data = _a.sent();
                        rawPem = pemFormat(Buffer.from(data), "private");
                        if (!password) {
                            return [2 /*return*/, rawPem];
                        }
                        decomposedKey = decomposePrivateKey("\n" + rawPem + "\n", {
                            format: "pkcs8-pem",
                        });
                        // @ts-ignore
                        decomposedKey["encryptionAlgorithm"] = {
                            keyDerivationFunc: {
                                id: "pbkdf2",
                                iterationCount: 10000,
                                keyLength: 32,
                                prf: "hmac-with-sha256",
                            },
                            encryptionScheme: "aes256-cbc",
                        };
                        return [2 /*return*/, composePrivateKey(decomposedKey, { password: password }).replace(/\n$/, "")];
                }
            });
        });
    };
    Encryption.prototype.exportPrivateKeyInBase64Url = function () {
        return __awaiter(this, void 0, void 0, function () {
            var privateKey, buffer;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.exportPrivateKey()];
                    case 1:
                        privateKey = _a.sent();
                        buffer = extractBuffer(privateKey, "private");
                        return [2 /*return*/, bufferToBase64UrlEncoded(buffer)];
                }
            });
        });
    };
    Encryption.prototype.exportPublicKey = function () {
        return __awaiter(this, void 0, void 0, function () {
            var data;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!this._publicKey) {
                            throw new Error("public key is not instantiated.");
                        }
                        return [4 /*yield*/, this._crypto.subtle.exportKey("spki", this._publicKey)];
                    case 1:
                        data = _a.sent();
                        return [2 /*return*/, pemFormat(Buffer.from(data), "public")];
                }
            });
        });
    };
    Encryption.prototype.exportPublicKeyInBase64Url = function () {
        return __awaiter(this, void 0, void 0, function () {
            var publicKey, buffer;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.exportPublicKey()];
                    case 1:
                        publicKey = _a.sent();
                        buffer = extractBuffer(publicKey, "public");
                        return [2 /*return*/, bufferToBase64UrlEncoded(buffer)];
                }
            });
        });
    };
    Encryption.prototype.rsaLargeMessageEncrypt = function (msg) {
        return __awaiter(this, void 0, void 0, function () {
            var bufferData, keySize, hashSize, blockSize, length, numBlocks, res, i, currentSize, block, bufferEncData, j;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!this.publicKey) {
                            throw new Error("public key is not passed properly.");
                        }
                        bufferData = Buffer.from(msg, "utf-8");
                        keySize = this.publicKey.algorithm.modulusLength / 8;
                        hashSize = 32;
                        blockSize = keySize - 2 * hashSize - 2;
                        length = bufferData.length;
                        numBlocks = Math.floor(length / blockSize);
                        if (length % blockSize !== 0) {
                            numBlocks += 1;
                        }
                        res = Buffer.alloc(keySize * numBlocks);
                        i = 0;
                        _a.label = 1;
                    case 1:
                        if (!(i < numBlocks)) return [3 /*break*/, 4];
                        currentSize = blockSize;
                        if (bufferData.length < (i + 1) * blockSize) {
                            currentSize = bufferData.length - i * blockSize;
                        }
                        block = bufferData.slice(i * blockSize, i * blockSize + currentSize);
                        return [4 /*yield*/, this.encrypt(block)];
                    case 2:
                        bufferEncData = _a.sent();
                        for (j = i * keySize; j < i * keySize + bufferEncData.length; j++) {
                            res[j] = bufferEncData[j - i * keySize];
                        }
                        _a.label = 3;
                    case 3:
                        i++;
                        return [3 /*break*/, 1];
                    case 4: return [2 /*return*/, res];
                }
            });
        });
    };
    Encryption.prototype.rsaLargeMessageDecrypt = function (cipher) {
        return __awaiter(this, void 0, void 0, function () {
            var keySize, length, numBlocks, res, i, block, pt;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!this.privateKey) {
                            throw new Error("private key is not passed properly.");
                        }
                        keySize = this.privateKey.algorithm.modulusLength / 8;
                        length = cipher.length;
                        if (length % keySize !== 0) {
                            throw new Error("invalid key size");
                        }
                        numBlocks = length / keySize;
                        res = "";
                        i = 0;
                        _a.label = 1;
                    case 1:
                        if (!(i < numBlocks)) return [3 /*break*/, 4];
                        block = cipher.slice(i * keySize, (i + 1) * keySize);
                        return [4 /*yield*/, this.decrypt(block)];
                    case 2:
                        pt = _a.sent();
                        res += pt;
                        _a.label = 3;
                    case 3:
                        i++;
                        return [3 /*break*/, 1];
                    case 4: return [2 /*return*/, res];
                }
            });
        });
    };
    return Encryption;
}());

var Signing = /** @class */ (function () {
    function Signing() {
    }
    Object.defineProperty(Signing.prototype, "privateKey", {
        get: function () {
            return Buffer.from(this._privateKey);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Signing.prototype, "publicKey", {
        get: function () {
            return Buffer.from(this._publicKey);
        },
        enumerable: false,
        configurable: true
    });
    Signing.prototype.generateKeyPair = function () {
        var keyPair = pki.ed25519.generateKeyPair();
        this._privateKey = keyPair.privateKey;
        this._publicKey = keyPair.publicKey;
    };
    Signing.prototype.importSeed = function (seed) {
        var bytes = base64UrlToBuffer(seed);
        var keyPair = pki.ed25519.generateKeyPair({ seed: bytes });
        this._privateKey = keyPair.privateKey;
        this._publicKey = keyPair.publicKey;
    };
    Signing.prototype.importPrivateKey = function (pem, password) {
        var decomposedKey = decomposePrivateKey("\n" + pem + "\n", { password: password, format: "pkcs8-pem" });
        var seed = decomposedKey.keyData.seed;
        var keyPair = pki.ed25519.generateKeyPair({ seed: seed });
        this._privateKey = keyPair.privateKey;
        this._publicKey = keyPair.publicKey;
    };
    Signing.prototype.importPrivateKeyInBase64Url = function (pem, password) {
        var pemData = base64UrlToBase64Encoded(pem);
        var p = pemFormat(Buffer.from(pemData, "base64"), "private");
        var decomposedKey = decomposePrivateKey("\n" + p + "\n", { password: password, format: "pkcs8-pem" });
        var seed = decomposedKey.keyData.seed;
        var keyPair = pki.ed25519.generateKeyPair({ seed: seed });
        this._privateKey = keyPair.privateKey;
        this._publicKey = keyPair.publicKey;
    };
    Signing.prototype.importPublicKey = function (pem) {
        var decomposedKey = decomposePublicKey("\n" + pem + "\n");
        this._publicKey = decomposedKey.keyData.bytes;
    };
    Signing.prototype.importPublicKeyInBase64Url = function (pem) {
        var pemData = base64UrlToBase64Encoded(pem);
        var p = pemFormat(Buffer.from(pemData, "base64"), "public");
        var decomposedKey = decomposePublicKey("\n" + p + "\n");
        this._publicKey = decomposedKey.keyData.bytes;
    };
    Signing.prototype.sign = function (message, option) {
        if (!this._privateKey)
            throw new Error("Private key is not set yet.");
        var decoded = base64UrlToBuffer(message);
        if ((option === null || option === void 0 ? void 0 : option.input) === "base64") {
            decoded = Buffer.from(message, "base64");
        }
        if ((option === null || option === void 0 ? void 0 : option.input) === "utf8") {
            decoded = Buffer.from(message);
        }
        if ((option === null || option === void 0 ? void 0 : option.input) === "hex") {
            decoded = Buffer.from(message, "hex");
        }
        var base64 = pki.ed25519.sign({ message: decoded, encoding: "binary", privateKey: this._privateKey }).toString("base64");
        if (base64.includes(",")) {
            // FIXME: Next.js was not working well with pki.ed25519.sign's format
            base64 = Buffer.from(base64.split(",").map(Number)).toString("base64");
        }
        if ((option === null || option === void 0 ? void 0 : option.output) === "base64") {
            return base64;
        }
        if ((option === null || option === void 0 ? void 0 : option.output) === "utf8") {
            return Buffer.from(base64, "base64").toString("utf8");
        }
        if ((option === null || option === void 0 ? void 0 : option.output) === "hex") {
            return Buffer.from(base64, "base64").toString("hex");
        }
        // Default is base64URL encoded string
        return base64ToBase64UrlEncoded(base64);
    };
    Signing.prototype.verify = function (message, signature, option) {
        if (!this._publicKey)
            throw new Error("Public key is not set yet.");
        var sig = "";
        if ((option === null || option === void 0 ? void 0 : option.encode) === "base64") {
            sig = signature;
        }
        else {
            // Default is base64URL encoded string
            sig = base64UrlToBase64Encoded(signature);
        }
        return pki.ed25519.verify({
            message: message,
            encoding: "binary",
            signature: Buffer.from(sig, "base64"),
            publicKey: this._publicKey
        });
    };
    Signing.prototype.exportPrivateKey = function (password) {
        if (!this._privateKey) {
            throw new Error("private key is not instantiated.");
        }
        var decomposed = {
            format: 'pkcs8-pem',
            keyAlgorithm: { id: 'ed25519' },
            keyData: {
                seed: this._privateKey.slice(0, 32),
            },
        };
        if (password) {
            // @ts-ignore
            decomposed["encryptionAlgorithm"] = {
                keyDerivationFunc: {
                    id: 'pbkdf2',
                    iterationCount: 10000,
                    keyLength: 32,
                    prf: 'hmac-with-sha256' // The pseudo-random function
                },
                encryptionScheme: 'aes256-cbc',
            };
        }
        return composePrivateKey(decomposed, { password: password }).replace(/\n$/, "");
    };
    Signing.prototype.exportPublicKey = function () {
        if (!this._publicKey) {
            throw new Error("public key is not instantiated.");
        }
        var decomposed = {
            format: 'spki-pem',
            keyAlgorithm: { id: 'ed25519' },
            keyData: {
                bytes: this._publicKey,
            },
        };
        return composePublicKey(decomposed).replace(/\n$/, "");
    };
    Signing.prototype.exportPrivateKeyInBase64Url = function () {
        var privPem = this.exportPrivateKey();
        var buffer = extractBuffer(privPem, "private");
        return bufferToBase64UrlEncoded(buffer);
    };
    Signing.prototype.exportPublicKeyInBase64Url = function () {
        var pubPem = this.exportPublicKey();
        var pubBuffer = extractBuffer(pubPem, "public");
        return bufferToBase64UrlEncoded(pubBuffer);
    };
    Signing.prototype.exportSeed = function () {
        var seedData = this._privateKey.slice(0, 32);
        // @ts-ignore
        return bufferToBase64UrlEncoded(seedData);
    };
    return Signing;
}());

var decodeTokenComponent = function (base64Url) {
    var base64 = base64UrlToBase64Encoded(base64Url);
    return JSON.parse(Buffer.from(base64, "base64").toString("binary"));
};
var encodeTokenComponent = function (json) {
    var base64Encoded = Buffer.from(JSON.stringify(json)).toString("base64");
    return base64ToBase64UrlEncoded(base64Encoded);
};
var composeMessage = function (header, payload) {
    return encodeTokenComponent(header) + "." + encodeTokenComponent(payload);
};
var parseJwt = function (token) {
    var _a = token.split("."), headerEncoded = _a[0], payloadEncoded = _a[1], signature = _a[2];
    var _b = [headerEncoded, payloadEncoded].map(decodeTokenComponent), header = _b[0], payload = _b[1];
    // @ts-ignore
    if (!header["alg"] || !header["typ"]) {
        throw new Error("Header format is not correct.");
    }
    // @ts-ignore
    return { header: header, headerEncoded: headerEncoded, payload: payload, payloadEncoded: payloadEncoded, signature: signature };
};
/**
 * Generates a JWT.
 * @param signing
 * @param payload
 */
var generateJwt = function (signing, payload) {
    // NOTE: Added `- 60` just in case a timestamp in the BE is not working properly.
    var timestamp = Number((new Date().getTime() / 1000).toFixed(0)) - 60;
    var header = {
        alg: "EdDSA",
        typ: "JWT",
    };
    var p = payload || {
        exp: timestamp + 60 * 60,
        iat: timestamp,
        signing_key: signing.exportPublicKey(),
    };
    var signature = signing.sign(composeMessage(header, p), { input: "utf8" });
    return encodeTokenComponent(header) + "." + encodeTokenComponent(p) + "." + signature;
};
/**
 * Generates an approval token
 * @param signing
 * @param clientId
 * @param entityId
 * @param approvedScopes
 * @param offerCode
 */
var generateApprovalToken = function (signing, clientId, entityId, approvedScopes, offerCode) {
    // NOTE: Added `- 60` just in case a timestamp in the BE is not working properly.
    var timestamp = Number((new Date().getTime() / 1000).toFixed(0)) - 60;
    var payload = {
        client_id: clientId,
        iat: timestamp,
        iss: entityId,
        scopes: approvedScopes.join(" "),
    };
    if (offerCode) {
        // @ts-ignore
        payload["offer_code"] = offerCode;
    }
    return generateJwt(signing, payload);
};
/**
 * Generates a claim token and a commitment
 * @param signing
 * @param providerId
 * @param entityId
 * @param scopeName
 * @param claim - claim object with raw values.
 * @returns { token: string; commitment: string }
 */
var generateClaimToken = function (signing, providerId, entityId, scopeName, claim) {
    var _a;
    // NOTE: Added `- 60` just in case a timestamp in the BE is not working properly.
    var timestamp = Number((new Date().getTime() / 1000).toFixed(0)) - 60;
    var commitment = generateCommitment();
    var key = scopeName.includes(":")
        ? scopeName + ":commitment"
        : scopeName + "_commitment";
    var scopeHash = sha256(unifyJsonData(_assign(_assign({}, claim), (_a = {}, _a[key] = commitment, _a))));
    var payload = {
        iat: timestamp,
        iss: providerId,
        user_id: entityId,
        scope_name: scopeName,
        scope_hash: scopeHash,
    };
    var token = generateJwt(signing, payload);
    return { token: token, commitment: commitment };
};
/**
 * Generates a request token
 * @param signing
 * @param encryptionPublicKey - Base64 URL encoded public key
 * @param scopes - Requested scopes list.
 * @param offerCode
 */
var generateRequestToken = function (signing, encryptionPublicKey, scopes, offerCode) {
    if (!scopes.includes("openid")) {
        throw new Error("openid is required.");
    }
    // NOTE: Added `- 60` just in case a timestamp in the BE is not working properly.
    var timestamp = Number((new Date().getTime() / 1000).toFixed(0)) - 60;
    var formattedScopes = scopes.join(" ");
    var payload = {
        encryption_public_key: encryptionPublicKey,
        iat: timestamp,
        scopes: formattedScopes,
    };
    if (offerCode) {
        // @ts-ignore
        payload["offer_code"] = offerCode;
    }
    return generateJwt(signing, payload);
};
/**
 * Generates an identity token
 * @param signing
 * @param entityId
 * @param identitySource
 * @param identityHash
 */
var generateIdentityToken = function (signing, entityId, identitySource, identityHash) {
    // NOTE: Added `- 60` just in case a timestamp in the BE is not working properly.
    var timestamp = Number((new Date().getTime() / 1000).toFixed(0)) - 60;
    var payload = {
        iat: timestamp,
        iss: entityId,
        identity_source: identitySource,
        identity_hash: identityHash,
    };
    return generateJwt(signing, payload);
};
var verifyJwt = function (jwt, signing) {
    var message = jwt.headerEncoded + "." + jwt.payloadEncoded;
    return signing.verify(message, jwt.signature);
};

// @ts-ignore
var ripemd160 = require("eosjs/dist/ripemd").RIPEMD160.hash;
var ecdsa = new ec("secp256k1");
var Wallet = /** @class */ (function () {
    function Wallet(mnemonic) {
        if (mnemonic.split(" ").length !== 12) {
            throw new Error("Mnemonic format is not correct");
        }
        this.mnemonic = mnemonic;
        var seed = mnemonicToSeedSync(this.mnemonic);
        this.masterNode = fromMasterSeed(seed);
    }
    Wallet.create = function () {
        var m = generateMnemonic();
        return new Wallet(m);
    };
    Wallet.prototype.getMnemonic = function () {
        return this.mnemonic;
    };
    Wallet.prototype.getMasterPrivateKey = function () {
        var masterPrivateKey = encode(128, this.masterNode.privateKey, true);
        // console.log(`==> getMasterPrivateKey : ${masterPrivateKey}`);
        return masterPrivateKey;
    };
    Wallet.prototype.getMasterPublicKey = function () {
        var masterPublicKey = this.masterNode.publicKey.toString("hex");
        // console.log(`==> getMasterPublicKey : ${masterPublicKey}`);
        return masterPublicKey;
    };
    Wallet.prototype.getEOSPrivateKey = function () {
        var childNode = this.masterNode.derive(this.getCoinKey("EOS"));
        var ellipticKeyPair = ecdsa.keyFromPrivate(childNode.privateKey);
        var eosPrivateKey = PrivateKey.fromElliptic(ellipticKeyPair, KeyType.k1, ecdsa);
        return eosPrivateKey.toLegacyString();
    };
    Wallet.prototype.getEOSPublicKey = function () {
        var childNode = this.masterNode.derive(this.getCoinKey("EOS"));
        var ellipticKeyPair = ecdsa.keyFromPrivate(childNode.privateKey);
        var eosPublicKey = PublicKey.fromElliptic(ellipticKeyPair, KeyType.k1, ecdsa);
        return this.convertToEosLegacyPublicKey(eosPublicKey);
    };
    Wallet.prototype.getCoinKey = function (coinType) {
        switch (coinType) {
            case "BTC": {
                return "";
            }
            case "EOS": {
                return 'm/44\'/194\'/0\'/0/0';
            }
            case "ETH": {
                return 'm/44\'/60\'/1\'/0/0';
            }
            case "XRP": {
                return "";
            }
        }
    };
    Wallet.prototype.convertToEosLegacyPublicKey = function (publicKey) {
        var keyString = publicKey.toString();
        var key = stringToPublicKey(keyString);
        if (key.type == KeyType.k1 && key.data.length === publicKeyDataSize) {
            var digest = new Uint8Array(ripemd160(key.data));
            var whole = new Uint8Array(publicKeyDataSize + 4);
            for (var i = 0; i < publicKeyDataSize; ++i)
                whole[i] = key.data[i];
            for (var i = 0; i < 4; ++i)
                whole[i + publicKeyDataSize] = digest[i];
            return "EOS" + binaryToBase58(whole);
        }
        else if (key.type == KeyType.r1 && key.data.length === publicKeyDataSize) {
            return keyString;
        }
        else {
            throw new Error("unrecognized public key format");
        }
    };
    return Wallet;
}());

export { Encryption, Signing, Wallet, base64ToBase64UrlEncoded, base64UrlToBase64Encoded, base64UrlToBuffer, bufferToBase64UrlEncoded, camelize, decamelize, generateApprovalToken, generateClaimToken, generateCommitment, generateIdentityToken, generateJwt, generateRequestToken, parseJwt, sha256, sha256ByEachField, unifyJsonData, verifyJwt };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguZXMuanMiLCJzb3VyY2VzIjpbIi4uL25vZGVfbW9kdWxlcy90c2xpYi90c2xpYi5lczYuanMiLCIuLi9zcmMvdXRpbHMudHMiLCIuLi9zcmMvZW5jcnlwdGlvbi50cyIsIi4uL3NyYy9zaWduaW5nLnRzIiwiLi4vc3JjL2p3dC50cyIsIi4uL3NyYy93YWxsZXQudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cclxuXHJcblBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxyXG5wdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXHJcblxyXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXHJcblJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxyXG5BTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXHJcbklORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxyXG5MT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxyXG5PVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXHJcblBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcbi8qIGdsb2JhbCBSZWZsZWN0LCBQcm9taXNlICovXHJcblxyXG52YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uKGQsIGIpIHtcclxuICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcclxuICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG59O1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZXh0ZW5kcyhkLCBiKSB7XHJcbiAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxyXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcclxuICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxufVxyXG5cclxuZXhwb3J0IHZhciBfX2Fzc2lnbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uIF9fYXNzaWduKHQpIHtcclxuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKSB0W3BdID0gc1twXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHQ7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fcmVzdChzLCBlKSB7XHJcbiAgICB2YXIgdCA9IHt9O1xyXG4gICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApXHJcbiAgICAgICAgdFtwXSA9IHNbcF07XHJcbiAgICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoZS5pbmRleE9mKHBbaV0pIDwgMCAmJiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocywgcFtpXSkpXHJcbiAgICAgICAgICAgICAgICB0W3BbaV1dID0gc1twW2ldXTtcclxuICAgICAgICB9XHJcbiAgICByZXR1cm4gdDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcclxuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xyXG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcclxuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3BhcmFtKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIGtleSkgeyBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIHBhcmFtSW5kZXgpOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX21ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hd2FpdGVyKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xyXG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XHJcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cclxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XHJcbiAgICB9KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZ2VuZXJhdG9yKHRoaXNBcmcsIGJvZHkpIHtcclxuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XHJcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xyXG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcclxuICAgICAgICB3aGlsZSAoXykgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xyXG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XHJcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxyXG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgdmFyIF9fY3JlYXRlQmluZGluZyA9IE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcclxuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XHJcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XHJcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xyXG4gICAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xyXG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xyXG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcclxuICAgIG9bazJdID0gbVtrXTtcclxufSk7XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19leHBvcnRTdGFyKG0sIG8pIHtcclxuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobywgcCkpIF9fY3JlYXRlQmluZGluZyhvLCBtLCBwKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fdmFsdWVzKG8pIHtcclxuICAgIHZhciBzID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5pdGVyYXRvciwgbSA9IHMgJiYgb1tzXSwgaSA9IDA7XHJcbiAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcclxuICAgIGlmIChvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgcmV0dXJuIHtcclxuICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XHJcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baSsrXSwgZG9uZTogIW8gfTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihzID8gXCJPYmplY3QgaXMgbm90IGl0ZXJhYmxlLlwiIDogXCJTeW1ib2wuaXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19yZWFkKG8sIG4pIHtcclxuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcclxuICAgIGlmICghbSkgcmV0dXJuIG87XHJcbiAgICB2YXIgaSA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZXJyb3IpIHsgZSA9IHsgZXJyb3I6IGVycm9yIH07IH1cclxuICAgIGZpbmFsbHkge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmaW5hbGx5IHsgaWYgKGUpIHRocm93IGUuZXJyb3I7IH1cclxuICAgIH1cclxuICAgIHJldHVybiBhcjtcclxufVxyXG5cclxuLyoqIEBkZXByZWNhdGVkICovXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3NwcmVhZCgpIHtcclxuICAgIGZvciAodmFyIGFyID0gW10sIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIGFyID0gYXIuY29uY2F0KF9fcmVhZChhcmd1bWVudHNbaV0pKTtcclxuICAgIHJldHVybiBhcjtcclxufVxyXG5cclxuLyoqIEBkZXByZWNhdGVkICovXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3NwcmVhZEFycmF5cygpIHtcclxuICAgIGZvciAodmFyIHMgPSAwLCBpID0gMCwgaWwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgaWw7IGkrKykgcyArPSBhcmd1bWVudHNbaV0ubGVuZ3RoO1xyXG4gICAgZm9yICh2YXIgciA9IEFycmF5KHMpLCBrID0gMCwgaSA9IDA7IGkgPCBpbDsgaSsrKVxyXG4gICAgICAgIGZvciAodmFyIGEgPSBhcmd1bWVudHNbaV0sIGogPSAwLCBqbCA9IGEubGVuZ3RoOyBqIDwgamw7IGorKywgaysrKVxyXG4gICAgICAgICAgICByW2tdID0gYVtqXTtcclxuICAgIHJldHVybiByO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19zcHJlYWRBcnJheSh0bywgZnJvbSwgcGFjaykge1xyXG4gICAgaWYgKHBhY2sgfHwgYXJndW1lbnRzLmxlbmd0aCA9PT0gMikgZm9yICh2YXIgaSA9IDAsIGwgPSBmcm9tLmxlbmd0aCwgYXI7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICBpZiAoYXIgfHwgIShpIGluIGZyb20pKSB7XHJcbiAgICAgICAgICAgIGlmICghYXIpIGFyID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSwgMCwgaSk7XHJcbiAgICAgICAgICAgIGFyW2ldID0gZnJvbVtpXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdG8uY29uY2F0KGFyIHx8IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20pKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXdhaXQodikge1xyXG4gICAgcmV0dXJuIHRoaXMgaW5zdGFuY2VvZiBfX2F3YWl0ID8gKHRoaXMudiA9IHYsIHRoaXMpIDogbmV3IF9fYXdhaXQodik7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2FzeW5jR2VuZXJhdG9yKHRoaXNBcmcsIF9hcmd1bWVudHMsIGdlbmVyYXRvcikge1xyXG4gICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxuICAgIHZhciBnID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pLCBpLCBxID0gW107XHJcbiAgICByZXR1cm4gaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIpLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGk7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgaWYgKGdbbl0pIGlbbl0gPSBmdW5jdGlvbiAodikgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKGEsIGIpIHsgcS5wdXNoKFtuLCB2LCBhLCBiXSkgPiAxIHx8IHJlc3VtZShuLCB2KTsgfSk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHJlc3VtZShuLCB2KSB7IHRyeSB7IHN0ZXAoZ1tuXSh2KSk7IH0gY2F0Y2ggKGUpIHsgc2V0dGxlKHFbMF1bM10sIGUpOyB9IH1cclxuICAgIGZ1bmN0aW9uIHN0ZXAocikgeyByLnZhbHVlIGluc3RhbmNlb2YgX19hd2FpdCA/IFByb21pc2UucmVzb2x2ZShyLnZhbHVlLnYpLnRoZW4oZnVsZmlsbCwgcmVqZWN0KSA6IHNldHRsZShxWzBdWzJdLCByKTsgfVxyXG4gICAgZnVuY3Rpb24gZnVsZmlsbCh2YWx1ZSkgeyByZXN1bWUoXCJuZXh0XCIsIHZhbHVlKTsgfVxyXG4gICAgZnVuY3Rpb24gcmVqZWN0KHZhbHVlKSB7IHJlc3VtZShcInRocm93XCIsIHZhbHVlKTsgfVxyXG4gICAgZnVuY3Rpb24gc2V0dGxlKGYsIHYpIHsgaWYgKGYodiksIHEuc2hpZnQoKSwgcS5sZW5ndGgpIHJlc3VtZShxWzBdWzBdLCBxWzBdWzFdKTsgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hc3luY0RlbGVnYXRvcihvKSB7XHJcbiAgICB2YXIgaSwgcDtcclxuICAgIHJldHVybiBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiwgZnVuY3Rpb24gKGUpIHsgdGhyb3cgZTsgfSksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGk7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4sIGYpIHsgaVtuXSA9IG9bbl0gPyBmdW5jdGlvbiAodikgeyByZXR1cm4gKHAgPSAhcCkgPyB7IHZhbHVlOiBfX2F3YWl0KG9bbl0odikpLCBkb25lOiBuID09PSBcInJldHVyblwiIH0gOiBmID8gZih2KSA6IHY7IH0gOiBmOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2FzeW5jVmFsdWVzKG8pIHtcclxuICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbiAgICB2YXIgbSA9IG9bU3ltYm9sLmFzeW5jSXRlcmF0b3JdLCBpO1xyXG4gICAgcmV0dXJuIG0gPyBtLmNhbGwobykgOiAobyA9IHR5cGVvZiBfX3ZhbHVlcyA9PT0gXCJmdW5jdGlvblwiID8gX192YWx1ZXMobykgOiBvW1N5bWJvbC5pdGVyYXRvcl0oKSwgaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIpLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGkpO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IGlbbl0gPSBvW25dICYmIGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7IHYgPSBvW25dKHYpLCBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCB2LmRvbmUsIHYudmFsdWUpOyB9KTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgZCwgdikgeyBQcm9taXNlLnJlc29sdmUodikudGhlbihmdW5jdGlvbih2KSB7IHJlc29sdmUoeyB2YWx1ZTogdiwgZG9uZTogZCB9KTsgfSwgcmVqZWN0KTsgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19tYWtlVGVtcGxhdGVPYmplY3QoY29va2VkLCByYXcpIHtcclxuICAgIGlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNvb2tlZCwgXCJyYXdcIiwgeyB2YWx1ZTogcmF3IH0pOyB9IGVsc2UgeyBjb29rZWQucmF3ID0gcmF3OyB9XHJcbiAgICByZXR1cm4gY29va2VkO1xyXG59O1xyXG5cclxudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9IE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xyXG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcclxuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcclxufTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2ltcG9ydFN0YXIobW9kKSB7XHJcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xyXG4gICAgdmFyIHJlc3VsdCA9IHt9O1xyXG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xyXG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2ltcG9ydERlZmF1bHQobW9kKSB7XHJcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IGRlZmF1bHQ6IG1vZCB9O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19jbGFzc1ByaXZhdGVGaWVsZEdldChyZWNlaXZlciwgc3RhdGUsIGtpbmQsIGYpIHtcclxuICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIGdldHRlclwiKTtcclxuICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHJlYWQgcHJpdmF0ZSBtZW1iZXIgZnJvbSBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xyXG4gICAgcmV0dXJuIGtpbmQgPT09IFwibVwiID8gZiA6IGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyKSA6IGYgPyBmLnZhbHVlIDogc3RhdGUuZ2V0KHJlY2VpdmVyKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fY2xhc3NQcml2YXRlRmllbGRTZXQocmVjZWl2ZXIsIHN0YXRlLCB2YWx1ZSwga2luZCwgZikge1xyXG4gICAgaWYgKGtpbmQgPT09IFwibVwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBtZXRob2QgaXMgbm90IHdyaXRhYmxlXCIpO1xyXG4gICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgc2V0dGVyXCIpO1xyXG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3Qgd3JpdGUgcHJpdmF0ZSBtZW1iZXIgdG8gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcclxuICAgIHJldHVybiAoa2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIsIHZhbHVlKSA6IGYgPyBmLnZhbHVlID0gdmFsdWUgOiBzdGF0ZS5zZXQocmVjZWl2ZXIsIHZhbHVlKSksIHZhbHVlO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19jbGFzc1ByaXZhdGVGaWVsZEluKHN0YXRlLCByZWNlaXZlcikge1xyXG4gICAgaWYgKHJlY2VpdmVyID09PSBudWxsIHx8ICh0eXBlb2YgcmVjZWl2ZXIgIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIHJlY2VpdmVyICE9PSBcImZ1bmN0aW9uXCIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHVzZSAnaW4nIG9wZXJhdG9yIG9uIG5vbi1vYmplY3RcIik7XHJcbiAgICByZXR1cm4gdHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciA9PT0gc3RhdGUgOiBzdGF0ZS5oYXMocmVjZWl2ZXIpO1xyXG59XHJcbiIsImltcG9ydCB7IEJ5dGVzIH0gZnJvbSBcIm5vZGUtZm9yZ2VcIjtcbmltcG9ydCB7IGNyZWF0ZUhhc2gsIHJhbmRvbUJ5dGVzIH0gZnJvbSBcImNyeXB0b1wiO1xuXG5jb25zdCBoZWFkZXJQcml2YXRlS2V5ID0gXCItLS0tLUJFR0lOIFBSSVZBVEUgS0VZLS0tLS1cXG5cIjtcbmNvbnN0IGZvb3RlclByaXZhdGVLZXkgPSBcIlxcbi0tLS0tRU5EIFBSSVZBVEUgS0VZLS0tLS1cIjtcbmNvbnN0IGhlYWRlclB1YmxpY0tleSA9IFwiLS0tLS1CRUdJTiBQVUJMSUMgS0VZLS0tLS1cXG5cIjtcbmNvbnN0IGZvb3RlclB1YmxpY0tleSA9IFwiXFxuLS0tLS1FTkQgUFVCTElDIEtFWS0tLS0tXCI7XG5cbmV4cG9ydCBjb25zdCB0b0J5dGVzID0gKGJ1ZjogQnVmZmVyKTogQnl0ZXMgPT4ge1xuICBsZXQgYnl0ZVN0cmluZyA9IFwiXCI7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYnVmLmxlbmd0aDsgKytpKSB7XG4gICAgYnl0ZVN0cmluZyArPSBTdHJpbmcuZnJvbUNvZGVQb2ludChidWZbaV0pO1xuICB9XG4gIHJldHVybiBieXRlU3RyaW5nO1xufTtcblxuZXhwb3J0IHR5cGUgS2V5VHlwZSA9IFwicHJpdmF0ZVwiIHwgXCJwdWJsaWNcIjtcblxuZXhwb3J0IGNvbnN0IGlzQXJyYXkgPSAoYTogYW55KSA9PiB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KGEpO1xufTtcblxuZXhwb3J0IGNvbnN0IGlzT2JqZWN0ID0gKG86IGFueSkgPT4ge1xuICByZXR1cm4gbyA9PT0gT2JqZWN0KG8pICYmICFpc0FycmF5KG8pICYmIHR5cGVvZiBvICE9PSBcImZ1bmN0aW9uXCI7XG59O1xuXG5leHBvcnQgY29uc3Qgc2hhMjU2ID0gKHZhbHVlOiBhbnkpID0+IHtcbiAgaWYgKGlzT2JqZWN0KHZhbHVlKSB8fCBpc0FycmF5KHZhbHVlKSkge1xuICAgIGNvbnN0IGJhc2U2NCA9IGNyZWF0ZUhhc2goXCJzaGEyNTZcIilcbiAgICAgIC51cGRhdGUoSlNPTi5zdHJpbmdpZnkodmFsdWUpKVxuICAgICAgLmRpZ2VzdChcImJhc2U2NFwiKTtcbiAgICByZXR1cm4gYmFzZTY0VG9CYXNlNjRVcmxFbmNvZGVkKGJhc2U2NCk7XG4gIH1cbiAgY29uc3QgYmFzZTY0ID0gY3JlYXRlSGFzaChcInNoYTI1NlwiKS51cGRhdGUodmFsdWUpLmRpZ2VzdChcImJhc2U2NFwiKTtcbiAgcmV0dXJuIGJhc2U2NFRvQmFzZTY0VXJsRW5jb2RlZChiYXNlNjQpO1xufTtcblxuZXhwb3J0IGNvbnN0IGdlbmVyYXRlQ29tbWl0bWVudCA9IChieXRlcz86IG51bWJlcik6IHN0cmluZyA9PiB7XG4gIGNvbnN0IGIgPSBieXRlcyB8fCAzMjtcbiAgcmV0dXJuIGJhc2U2NFRvQmFzZTY0VXJsRW5jb2RlZChyYW5kb21CeXRlcyhiKS50b1N0cmluZyhcImJhc2U2NFwiKSk7XG59O1xuXG5leHBvcnQgY29uc3QgZXh0cmFjdEJ1ZmZlciA9IChwZW1TdHJpbmc6IHN0cmluZywgdHlwZTogS2V5VHlwZSk6IEJ1ZmZlciA9PiB7XG4gIGlmICh0eXBlID09PSBcInB1YmxpY1wiKSB7XG4gICAgbGV0IGZvcm1hdHRlZFB1YmxpY0tleVBlbSA9IHBlbVN0cmluZy5zdGFydHNXaXRoKGhlYWRlclB1YmxpY0tleSlcbiAgICAgID8gcGVtU3RyaW5nLnNwbGl0KGhlYWRlclB1YmxpY0tleSlbMV1cbiAgICAgIDogcGVtU3RyaW5nO1xuICAgIGZvcm1hdHRlZFB1YmxpY0tleVBlbSA9IGZvcm1hdHRlZFB1YmxpY0tleVBlbS5lbmRzV2l0aChmb290ZXJQdWJsaWNLZXkpXG4gICAgICA/IGZvcm1hdHRlZFB1YmxpY0tleVBlbS5zcGxpdChmb290ZXJQdWJsaWNLZXkpWzBdXG4gICAgICA6IGZvcm1hdHRlZFB1YmxpY0tleVBlbTtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oZm9ybWF0dGVkUHVibGljS2V5UGVtLnJlcGxhY2UoL1xcci9nLCBcIlwiKSwgXCJiYXNlNjRcIik7XG4gIH0gZWxzZSB7XG4gICAgbGV0IGZvcm1hdHRlZFByaXZhdGVLZXlQZW0gPSBwZW1TdHJpbmcuc3RhcnRzV2l0aChoZWFkZXJQcml2YXRlS2V5KVxuICAgICAgPyBwZW1TdHJpbmcuc3BsaXQoaGVhZGVyUHJpdmF0ZUtleSlbMV1cbiAgICAgIDogcGVtU3RyaW5nO1xuICAgIGZvcm1hdHRlZFByaXZhdGVLZXlQZW0gPSBmb3JtYXR0ZWRQcml2YXRlS2V5UGVtLmVuZHNXaXRoKGZvb3RlclByaXZhdGVLZXkpXG4gICAgICA/IGZvcm1hdHRlZFByaXZhdGVLZXlQZW0uc3BsaXQoZm9vdGVyUHJpdmF0ZUtleSlbMF1cbiAgICAgIDogZm9ybWF0dGVkUHJpdmF0ZUtleVBlbTtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oZm9ybWF0dGVkUHJpdmF0ZUtleVBlbS5yZXBsYWNlKC9cXHIvZywgXCJcIiksIFwiYmFzZTY0XCIpO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgcGVtRm9ybWF0ID0gKGJ1ZmZlcjogQnVmZmVyLCB0eXBlOiBLZXlUeXBlKTogc3RyaW5nID0+IHtcbiAgaWYgKHR5cGUgPT09IFwicHVibGljXCIpIHtcbiAgICBjb25zdCBiYXNlNjQgPSBidWZmZXIudG9TdHJpbmcoXCJiYXNlNjRcIik7XG4gICAgaWYgKGJhc2U2NC5pbmNsdWRlcyhcIlxcblwiKSkge1xuICAgICAgcmV0dXJuIGAke2hlYWRlclB1YmxpY0tleX0ke2Jhc2U2NH0ke2Zvb3RlclB1YmxpY0tleX1gO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICBjb25zdCBrZXkgPSBiYXNlNjQubWF0Y2goLy57MSw2NH0vZykuam9pbihcIlxcblwiKTtcbiAgICAgIHJldHVybiBgJHtoZWFkZXJQdWJsaWNLZXl9JHtrZXl9JHtmb290ZXJQdWJsaWNLZXl9YDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgYmFzZTY0ID0gYnVmZmVyLnRvU3RyaW5nKFwiYmFzZTY0XCIpO1xuICAgIGlmIChiYXNlNjQuaW5jbHVkZXMoXCJcXG5cIikpIHtcbiAgICAgIHJldHVybiBgJHtoZWFkZXJQcml2YXRlS2V5fSR7YmFzZTY0fSR7Zm9vdGVyUHJpdmF0ZUtleX1gO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICBjb25zdCBrZXkgPSBiYXNlNjQubWF0Y2goLy57MSw2NH0vZykuam9pbihcIlxcblwiKTtcbiAgICAgIHJldHVybiBgJHtoZWFkZXJQcml2YXRlS2V5fSR7a2V5fSR7Zm9vdGVyUHJpdmF0ZUtleX1gO1xuICAgIH1cbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IGJ1ZmZlclRvQmFzZTY0VXJsRW5jb2RlZCA9IChidWZmZXI6IEJ1ZmZlcik6IHN0cmluZyA9PiB7XG4gIGNvbnN0IGJhc2U2NCA9IGJ1ZmZlci50b1N0cmluZyhcImJhc2U2NFwiKTtcbiAgcmV0dXJuIGJhc2U2NFRvQmFzZTY0VXJsRW5jb2RlZChiYXNlNjQpO1xufTtcblxuZXhwb3J0IGNvbnN0IGJhc2U2NFRvQmFzZTY0VXJsRW5jb2RlZCA9IChiYXNlNjQ6IHN0cmluZyk6IHN0cmluZyA9PiB7XG4gIHJldHVybiBiYXNlNjQucmVwbGFjZSgvPS9nLCBcIlwiKS5yZXBsYWNlKC9cXCsvZywgXCItXCIpLnJlcGxhY2UoL1xcLy9nLCBcIl9cIik7XG59O1xuXG5leHBvcnQgY29uc3QgYmFzZTY0VXJsVG9CYXNlNjRFbmNvZGVkID0gKGJhc2U2NFVybDogc3RyaW5nKTogc3RyaW5nID0+IHtcbiAgcmV0dXJuIHBhZFN0cmluZyhiYXNlNjRVcmwpLnJlcGxhY2UoL1xcLS9nLCBcIitcIikucmVwbGFjZSgvXy9nLCBcIi9cIik7XG59O1xuXG5leHBvcnQgY29uc3QgYmFzZTY0VXJsVG9CdWZmZXIgPSAoYmFzZTY0VXJsOiBzdHJpbmcpOiBCdWZmZXIgPT4ge1xuICBjb25zdCBiYXNlNjQgPSBiYXNlNjRVcmxUb0Jhc2U2NEVuY29kZWQoYmFzZTY0VXJsKTtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKGJhc2U2NCwgXCJiYXNlNjRcIik7XG59O1xuXG5leHBvcnQgY29uc3Qgc2hhMjU2QnlFYWNoRmllbGQgPSAobzogYW55KTogYW55ID0+IHtcbiAgaWYgKGlzT2JqZWN0KG8pKSB7XG4gICAgY29uc3QgbiA9IHt9O1xuXG4gICAgT2JqZWN0LmtleXMobykuZm9yRWFjaCgoazogc3RyaW5nKSA9PiB7XG4gICAgICBpZiAoayA9PT0gXCJ2ZXJpZmllZFwiKSB7XG4gICAgICAgIC8vIElnbm9yZSBgdmVyaWZpZWRgIGZsYWdcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBuW2tdID0gb1trXTtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgfSBlbHNlIGlmIChvW2tdID09PSBcIlwiIHx8IG9ba10gPT09IG51bGwpIHtcbiAgICAgICAgLy8gSWdub3JlIGVtcHR5IHZhbHVlc1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIG5ba10gPSBvW2tdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBuW2tdID0gc2hhMjU2QnlFYWNoRmllbGQob1trXSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIG47XG4gIH1cbiAgaWYgKGlzQXJyYXkobykpIHtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgcmV0dXJuIG8ubWFwKChpKSA9PiBzaGEyNTZCeUVhY2hGaWVsZChpKSk7XG4gIH1cblxuICByZXR1cm4gc2hhMjU2KG8pO1xufTtcblxuY29uc3QgcGFkU3RyaW5nID0gKGlucHV0OiBzdHJpbmcpOiBzdHJpbmcgPT4ge1xuICBjb25zdCBzZWdtZW50TGVuZ3RoID0gNDtcbiAgY29uc3Qgc3RyaW5nTGVuZ3RoID0gaW5wdXQubGVuZ3RoO1xuICBjb25zdCBkaWZmID0gc3RyaW5nTGVuZ3RoICUgc2VnbWVudExlbmd0aDtcblxuICBpZiAoIWRpZmYpIHtcbiAgICByZXR1cm4gaW5wdXQ7XG4gIH1cblxuICBsZXQgcG9zaXRpb24gPSBzdHJpbmdMZW5ndGg7XG4gIGxldCBwYWRMZW5ndGggPSBzZWdtZW50TGVuZ3RoIC0gZGlmZjtcbiAgY29uc3QgcGFkZGVkU3RyaW5nTGVuZ3RoID0gc3RyaW5nTGVuZ3RoICsgcGFkTGVuZ3RoO1xuICBsZXQgYnVmZmVyID0gQnVmZmVyLmFsbG9jKHBhZGRlZFN0cmluZ0xlbmd0aCk7XG5cbiAgYnVmZmVyLndyaXRlKGlucHV0KTtcblxuICB3aGlsZSAocGFkTGVuZ3RoLS0pIHtcbiAgICBidWZmZXIud3JpdGUoXCI9XCIsIHBvc2l0aW9uKyspO1xuICB9XG5cbiAgcmV0dXJuIGJ1ZmZlci50b1N0cmluZygpO1xufTtcblxuLyoqXG4gKiBVbmlmeSB0aGUgSnNvbiBkYXRhXG4gKiBAcGFyYW0gZGF0YSAtIGNhbiBiZSBhbnkgdHlwZVxuICogUmV0dXJuIHRoZSBvcmRlcmVkIGpzb24gb2JqZWN0XG4gKi9cblxuZXhwb3J0IGNvbnN0IHVuaWZ5SnNvbkRhdGEgPSAodW5vcmRlcmVkT2JqZWN0OiBhbnkpID0+IHtcbiAgaWYgKCF1bm9yZGVyZWRPYmplY3QpIHtcbiAgICByZXR1cm4gdW5vcmRlcmVkT2JqZWN0O1xuICB9XG5cbiAgaWYgKHR5cGVvZiB1bm9yZGVyZWRPYmplY3QgIT09IFwib2JqZWN0XCIpIHtcbiAgICByZXR1cm4gdW5vcmRlcmVkT2JqZWN0O1xuICB9XG5cbiAgcmV0dXJuIE9iamVjdC5rZXlzKHVub3JkZXJlZE9iamVjdClcbiAgICAuc29ydCgpXG4gICAgLnJlZHVjZSgocmVzLCBrZXkpID0+IHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHVub3JkZXJlZE9iamVjdFtrZXldKSkge1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHJlc1trZXldID0gdW5vcmRlcmVkT2JqZWN0W2tleV0ubWFwKHVuaWZ5SnNvbkRhdGEpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdW5vcmRlcmVkT2JqZWN0W2tleV0gPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICByZXNba2V5XSA9IHVuaWZ5SnNvbkRhdGEodW5vcmRlcmVkT2JqZWN0W2tleV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICByZXNba2V5XSA9IHVub3JkZXJlZE9iamVjdFtrZXldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlcztcbiAgICB9LCB7fSk7XG59O1xuXG5jb25zdCB0b0NhbWVsID0gKHM6IHN0cmluZyk6IHN0cmluZyA9PiB7XG4gIHJldHVybiBzLnJlcGxhY2UoLyhbLV9dW2Etel0pL2dpLCAoJDEpID0+IHtcbiAgICByZXR1cm4gJDEudG9VcHBlckNhc2UoKS5yZXBsYWNlKFwiLVwiLCBcIlwiKS5yZXBsYWNlKFwiX1wiLCBcIlwiKTtcbiAgfSk7XG59O1xuXG5jb25zdCB0b1NuYWtlID0gKHM6IHN0cmluZyk6IHN0cmluZyA9PiB7XG4gIGNvbnN0IHJlc3VsdCA9IHMucmVwbGFjZSgvKFtBLVpdKS9nLCBcIiAkMVwiKTtcbiAgcmV0dXJuIHJlc3VsdC5zcGxpdChcIiBcIikuam9pbihcIl9cIikudG9Mb3dlckNhc2UoKTtcbn07XG5cbmV4cG9ydCBjb25zdCBjYW1lbGl6ZSA9IChvOiBhbnkpOiBhbnkgPT4ge1xuICBpZiAoaXNPYmplY3QobykpIHtcbiAgICBjb25zdCBuID0ge307XG5cbiAgICBPYmplY3Qua2V5cyhvKS5mb3JFYWNoKChrKSA9PiB7XG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICBuW3RvQ2FtZWwoayldID0gY2FtZWxpemUob1trXSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIG47XG4gIH0gZWxzZSBpZiAoaXNBcnJheShvKSkge1xuICAgIHJldHVybiBvLm1hcCgoaTogYW55KSA9PiB7XG4gICAgICByZXR1cm4gY2FtZWxpemUoaSk7XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gbztcbn07XG5cbmV4cG9ydCBjb25zdCBkZWNhbWVsaXplID0gKG86IGFueSk6IGFueSA9PiB7XG4gIGlmIChpc09iamVjdChvKSkge1xuICAgIGNvbnN0IG4gPSB7fTtcblxuICAgIE9iamVjdC5rZXlzKG8pLmZvckVhY2goKGspID0+IHtcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIG5bdG9TbmFrZShrKV0gPSBkZWNhbWVsaXplKG9ba10pO1xuICAgIH0pO1xuICAgIHJldHVybiBuO1xuICB9IGVsc2UgaWYgKGlzQXJyYXkobykpIHtcbiAgICByZXR1cm4gby5tYXAoKGk6IGFueSkgPT4ge1xuICAgICAgcmV0dXJuIGRlY2FtZWxpemUoaSk7XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gbztcbn07XG4iLCIvLyBAdHMtaWdub3JlXG5pbXBvcnQgKiBhcyB3ZWJjcnlwdG8gZnJvbSBcIkBwZWN1bGlhci93ZWJjcnlwdG9cIjtcbmltcG9ydCB7XG4gIGNvbXBvc2VQcml2YXRlS2V5LFxuICBkZWNvbXBvc2VQcml2YXRlS2V5LFxufSBmcm9tIFwiQGNyZWRpZnkvY3J5cHRvLWtleS1jb21wb3NlclwiO1xuaW1wb3J0IHtcbiAgYmFzZTY0VXJsVG9CYXNlNjRFbmNvZGVkLFxuICBidWZmZXJUb0Jhc2U2NFVybEVuY29kZWQsXG4gIGV4dHJhY3RCdWZmZXIsXG4gIGlzQXJyYXksXG4gIGlzT2JqZWN0LFxuICBwZW1Gb3JtYXQsXG59IGZyb20gXCIuL3V0aWxzXCI7XG5pbXBvcnQgdHlwZSB7IEVuY3J5cHRpb24gYXMgSUVuY3J5cHRpb24gfSBmcm9tIFwiLi4vdHlwZXNcIjtcblxuZXhwb3J0IGNvbnN0IERFRkFVTFRfS0VZX1NJWkUgPSAzMDcyO1xuXG5jbGFzcyBFbmNyeXB0aW9uIGltcGxlbWVudHMgSUVuY3J5cHRpb24ge1xuICBwcml2YXRlIF9jcnlwdG86IENyeXB0bztcbiAgcHJpdmF0ZSBfcHJpdmF0ZUtleTogQ3J5cHRvS2V5O1xuICBwcml2YXRlIF9wdWJsaWNLZXk6IENyeXB0b0tleTtcblxuICBwdWJsaWMgZ2V0IHByaXZhdGVLZXkoKTogQ3J5cHRvS2V5IHtcbiAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZUtleTtcbiAgfVxuICBwdWJsaWMgZ2V0IHB1YmxpY0tleSgpOiBDcnlwdG9LZXkge1xuICAgIHJldHVybiB0aGlzLl9wdWJsaWNLZXk7XG4gIH1cblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBjb25zdCBjaGVja0lzQnJvd3NlciA9IG5ldyBGdW5jdGlvbihcbiAgICAgIFwidHJ5IHtyZXR1cm4gdGhpcz09PXdpbmRvdzt9Y2F0Y2goZSl7IHJldHVybiBmYWxzZTt9XCJcbiAgICApO1xuICAgIGNvbnN0IGlzQnJvd3NlciA9IGNoZWNrSXNCcm93c2VyKCk7XG4gICAgaWYgKGlzQnJvd3Nlcikge1xuICAgICAgdGhpcy5fY3J5cHRvID0gY3J5cHRvO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9jcnlwdG8gPSBuZXcgd2ViY3J5cHRvLkNyeXB0bygpO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBnZW5lcmF0ZUtleVBhaXIoXG4gICAga2V5U2l6ZTogbnVtYmVyID0gREVGQVVMVF9LRVlfU0laRVxuICApOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCBrZXlzID0gYXdhaXQgdGhpcy5fY3J5cHRvLnN1YnRsZS5nZW5lcmF0ZUtleShcbiAgICAgIHtcbiAgICAgICAgbmFtZTogXCJSU0EtT0FFUFwiLFxuICAgICAgICBoYXNoOiBcIlNIQS0yNTZcIixcbiAgICAgICAgcHVibGljRXhwb25lbnQ6IG5ldyBVaW50OEFycmF5KFsxLCAwLCAxXSksIC8vIDB4MDMgb3IgMHgwMTAwMDFcbiAgICAgICAgbW9kdWx1c0xlbmd0aDoga2V5U2l6ZSxcbiAgICAgIH0sXG4gICAgICB0cnVlLFxuICAgICAgW1wiZW5jcnlwdFwiLCBcImRlY3J5cHRcIl1cbiAgICApO1xuICAgIHRoaXMuX3ByaXZhdGVLZXkgPSBrZXlzLnByaXZhdGVLZXkhO1xuICAgIHRoaXMuX3B1YmxpY0tleSA9IGtleXMucHVibGljS2V5ITtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBpbXBvcnRQcml2YXRlS2V5KHBlbTogc3RyaW5nLCBwYXNzd29yZD86IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICAgIGxldCByYXdQZW0gPSBwZW07XG4gICAgaWYgKHBhc3N3b3JkKSB7XG4gICAgICBjb25zdCBkZWNvbXBvc2VkS2V5ID0gZGVjb21wb3NlUHJpdmF0ZUtleShgXFxuJHtwZW19XFxuYCwge1xuICAgICAgICBwYXNzd29yZCxcbiAgICAgICAgZm9ybWF0OiBcInBrY3M4LXBlbVwiLFxuICAgICAgfSk7XG4gICAgICAvLyBSZW1vdmUgdW5uZWNlc3NhcnkgcHJvcGVydHlcbiAgICAgIGRlbGV0ZSBkZWNvbXBvc2VkS2V5W1wiZW5jcnlwdGlvbkFsZ29yaXRobVwiXTtcbiAgICAgIHJhd1BlbSA9IGNvbXBvc2VQcml2YXRlS2V5KGRlY29tcG9zZWRLZXkpLnJlcGxhY2UoL1xcbiQvLCBcIlwiKTtcbiAgICB9XG4gICAgY29uc3QgYnVmZmVyID0gZXh0cmFjdEJ1ZmZlcihyYXdQZW0sIFwicHJpdmF0ZVwiKTtcbiAgICBjb25zdCBrZXkgPSBhd2FpdCB0aGlzLl9jcnlwdG8uc3VidGxlLmltcG9ydEtleShcbiAgICAgIFwicGtjczhcIixcbiAgICAgIGJ1ZmZlcixcbiAgICAgIHtcbiAgICAgICAgbmFtZTogXCJSU0EtT0FFUFwiLFxuICAgICAgICBoYXNoOiBcIlNIQS0yNTZcIixcbiAgICAgIH0sXG4gICAgICB0cnVlLFxuICAgICAgW1wiZGVjcnlwdFwiXVxuICAgICk7XG4gICAgdGhpcy5fcHJpdmF0ZUtleSA9IGtleTtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBpbXBvcnRQcml2YXRlS2V5SW5CYXNlNjRVcmwoXG4gICAgcGVtOiBzdHJpbmcsXG4gICAgcGFzc3dvcmQ/OiBzdHJpbmdcbiAgKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgbGV0IHJhd1BlbSA9IGJhc2U2NFVybFRvQmFzZTY0RW5jb2RlZChwZW0pO1xuICAgIHJhd1BlbSA9IHBlbUZvcm1hdChCdWZmZXIuZnJvbShyYXdQZW0sIFwiYmFzZTY0XCIpLCBcInByaXZhdGVcIik7XG4gICAgaWYgKHBhc3N3b3JkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQYXNzd29yZCBkZWNyeXB0aW9uIGlzIG5vdCBzdXBwb3J0ZWQgeWV0LlwiKTtcbiAgICAgIC8vIGNvbnN0IGRlY29tcG9zZWRLZXkgPSBkZWNvbXBvc2VQcml2YXRlS2V5KGBcXG4ke3BlbX1cXG5gLCB7IHBhc3N3b3JkLCBmb3JtYXQ6IFwicGtjczgtcGVtXCIgfSk7XG4gICAgICAvLyBSZW1vdmUgdW5uZWNlc3NhcnkgcHJvcGVydHlcbiAgICAgIC8vIGRlbGV0ZSBkZWNvbXBvc2VkS2V5W1wiZW5jcnlwdGlvbkFsZ29yaXRobVwiXTtcbiAgICAgIC8vIHJhd1BlbSA9IGNvbXBvc2VQcml2YXRlS2V5KGRlY29tcG9zZWRLZXkpO1xuICAgIH1cbiAgICBjb25zdCBidWZmZXIgPSBleHRyYWN0QnVmZmVyKHJhd1BlbSwgXCJwcml2YXRlXCIpO1xuICAgIGNvbnN0IGtleSA9IGF3YWl0IHRoaXMuX2NyeXB0by5zdWJ0bGUuaW1wb3J0S2V5KFxuICAgICAgXCJwa2NzOFwiLFxuICAgICAgYnVmZmVyLFxuICAgICAge1xuICAgICAgICBuYW1lOiBcIlJTQS1PQUVQXCIsXG4gICAgICAgIGhhc2g6IFwiU0hBLTI1NlwiLFxuICAgICAgfSxcbiAgICAgIHRydWUsXG4gICAgICBbXCJkZWNyeXB0XCJdXG4gICAgKTtcbiAgICB0aGlzLl9wcml2YXRlS2V5ID0ga2V5O1xuICB9XG5cbiAgcHVibGljIGFzeW5jIGltcG9ydFB1YmxpY0tleShwZW06IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IGJ1ZmZlciA9IGV4dHJhY3RCdWZmZXIocGVtLCBcInB1YmxpY1wiKTtcbiAgICBjb25zdCBrZXkgPSBhd2FpdCB0aGlzLl9jcnlwdG8uc3VidGxlLmltcG9ydEtleShcbiAgICAgIFwic3BraVwiLFxuICAgICAgYnVmZmVyLFxuICAgICAge1xuICAgICAgICBuYW1lOiBcIlJTQS1PQUVQXCIsXG4gICAgICAgIGhhc2g6IFwiU0hBLTI1NlwiLFxuICAgICAgfSxcbiAgICAgIHRydWUsXG4gICAgICBbXCJlbmNyeXB0XCJdXG4gICAgKTtcbiAgICB0aGlzLl9wdWJsaWNLZXkgPSBrZXk7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgaW1wb3J0UHVibGljS2V5SW5CYXNlNjRVcmwocGVtOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCBiYXNlNjQgPSBiYXNlNjRVcmxUb0Jhc2U2NEVuY29kZWQocGVtKTtcbiAgICBjb25zdCBidWZmZXIgPSBCdWZmZXIuZnJvbShiYXNlNjQsIFwiYmFzZTY0XCIpO1xuICAgIGNvbnN0IGtleSA9IGF3YWl0IHRoaXMuX2NyeXB0by5zdWJ0bGUuaW1wb3J0S2V5KFxuICAgICAgXCJzcGtpXCIsXG4gICAgICBidWZmZXIsXG4gICAgICB7XG4gICAgICAgIG5hbWU6IFwiUlNBLU9BRVBcIixcbiAgICAgICAgaGFzaDogXCJTSEEtMjU2XCIsXG4gICAgICB9LFxuICAgICAgdHJ1ZSxcbiAgICAgIFtcImVuY3J5cHRcIl1cbiAgICApO1xuICAgIHRoaXMuX3B1YmxpY0tleSA9IGtleTtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBlbmNyeXB0KGRhdGE6IEJ1ZmZlcik6IFByb21pc2U8QnVmZmVyPiB7XG4gICAgaWYgKCF0aGlzLl9wdWJsaWNLZXkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcInB1YmxpYyBrZXkgaXMgbm90IHBhc3NlZCBwcm9wZXJseS5cIik7XG4gICAgfVxuICAgIGNvbnN0IGVuYyA9IGF3YWl0IHRoaXMuX2NyeXB0by5zdWJ0bGUuZW5jcnlwdChcbiAgICAgIFwiUlNBLU9BRVBcIixcbiAgICAgIHRoaXMuX3B1YmxpY0tleSxcbiAgICAgIGRhdGFcbiAgICApO1xuICAgIHJldHVybiBCdWZmZXIuZnJvbShuZXcgVWludDhBcnJheShlbmMpKTtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBlbmNyeXB0U3RyaW5nVG9CYXNlNjRVcmxTdHJpbmcoXG4gICAgbWVzc2FnZTogc3RyaW5nXG4gICk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgaWYgKCF0aGlzLl9wdWJsaWNLZXkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcInB1YmxpYyBrZXkgaXMgbm90IHBhc3NlZCBwcm9wZXJseS5cIik7XG4gICAgfVxuXG4gICAgY29uc3QgZW5jID0gYXdhaXQgdGhpcy5yc2FMYXJnZU1lc3NhZ2VFbmNyeXB0KG1lc3NhZ2UpO1xuICAgIHJldHVybiBidWZmZXJUb0Jhc2U2NFVybEVuY29kZWQoZW5jKTtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBlbmNyeXB0RmllbGRCeUZpZWxkKHBsYWluOiBhbnkpOiBQcm9taXNlPGFueT4ge1xuICAgIGlmIChpc09iamVjdChwbGFpbikpIHtcbiAgICAgIGNvbnN0IG4gPSB7fTtcblxuICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHBsYWluKTtcbiAgICAgIGZvciAoY29uc3QgayBvZiBrZXlzKSB7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgbltrXSA9IGF3YWl0IHRoaXMuZW5jcnlwdEZpZWxkQnlGaWVsZChwbGFpbltrXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbjtcbiAgICB9IGVsc2UgaWYgKGlzQXJyYXkocGxhaW4pKSB7XG4gICAgICBjb25zdCBuID0gW107XG4gICAgICBmb3IgKGNvbnN0IGkgb2YgcGxhaW4pIHtcbiAgICAgICAgY29uc3QgZCA9IGF3YWl0IHRoaXMuZW5jcnlwdEZpZWxkQnlGaWVsZChpKTtcbiAgICAgICAgbi5wdXNoKGQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG47XG4gICAgfVxuXG4gICAgaWYgKHBsYWluID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKHBsYWluID09PSBcIlwiKSB7XG4gICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG4gICAgaWYgKHBsYWluID09PSB0cnVlKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHBsYWluID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiBhd2FpdCB0aGlzLmVuY3J5cHRTdHJpbmdUb0Jhc2U2NFVybFN0cmluZyhwbGFpbik7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgZGVjcnlwdChjaXBoZXI6IEJ1ZmZlcik6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgaWYgKCF0aGlzLl9wcml2YXRlS2V5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJwcml2YXRlIGtleSBpcyBub3QgcGFzc2VkIHByb3Blcmx5LlwiKTtcbiAgICB9XG4gICAgY29uc3QgZGVjID0gYXdhaXQgdGhpcy5fY3J5cHRvLnN1YnRsZS5kZWNyeXB0KFxuICAgICAgXCJSU0EtT0FFUFwiLFxuICAgICAgdGhpcy5fcHJpdmF0ZUtleSxcbiAgICAgIGNpcGhlclxuICAgICk7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKGRlYykudG9TdHJpbmcoXCJ1dGY4XCIpO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIGRlY3J5cHRCYXNlNjRVcmxTdHJpbmdUb1N0cmluZyhjaXBoZXI6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgY29uc3QgYmFzZTY0ID0gYmFzZTY0VXJsVG9CYXNlNjRFbmNvZGVkKGNpcGhlcik7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMucnNhTGFyZ2VNZXNzYWdlRGVjcnlwdChCdWZmZXIuZnJvbShiYXNlNjQsIFwiYmFzZTY0XCIpKTtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBkZWNyeXB0RmllbGRCeUZpZWxkKGNpcGhlcjogYW55KTogUHJvbWlzZTxhbnk+IHtcbiAgICBpZiAoaXNPYmplY3QoY2lwaGVyKSkge1xuICAgICAgY29uc3QgbiA9IHt9O1xuXG4gICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoY2lwaGVyKTtcbiAgICAgIGZvciAoY29uc3QgayBvZiBrZXlzKSB7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgbltrXSA9IGF3YWl0IHRoaXMuZGVjcnlwdEZpZWxkQnlGaWVsZChjaXBoZXJba10pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG47XG4gICAgfSBlbHNlIGlmIChpc0FycmF5KGNpcGhlcikpIHtcbiAgICAgIGNvbnN0IG4gPSBbXTtcbiAgICAgIGZvciAoY29uc3QgaSBvZiBjaXBoZXIpIHtcbiAgICAgICAgY29uc3QgZCA9IGF3YWl0IHRoaXMuZGVjcnlwdEZpZWxkQnlGaWVsZChpKTtcbiAgICAgICAgbi5wdXNoKGQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG47XG4gICAgfVxuXG4gICAgaWYgKGNpcGhlciA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmIChjaXBoZXIgPT09IFwiXCIpIHtcbiAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cbiAgICBpZiAoY2lwaGVyID09PSB0cnVlKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGNpcGhlciA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXdhaXQgdGhpcy5kZWNyeXB0QmFzZTY0VXJsU3RyaW5nVG9TdHJpbmcoY2lwaGVyKTtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBleHBvcnRQcml2YXRlS2V5KHBhc3N3b3JkPzogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICBpZiAoIXRoaXMuX3ByaXZhdGVLZXkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcInByaXZhdGUga2V5IGlzIG5vdCBpbnN0YW50aWF0ZWQuXCIpO1xuICAgIH1cblxuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLl9jcnlwdG8uc3VidGxlLmV4cG9ydEtleShcInBrY3M4XCIsIHRoaXMuX3ByaXZhdGVLZXkpO1xuICAgIGNvbnN0IHJhd1BlbSA9IHBlbUZvcm1hdChCdWZmZXIuZnJvbShkYXRhKSwgXCJwcml2YXRlXCIpO1xuICAgIGlmICghcGFzc3dvcmQpIHtcbiAgICAgIHJldHVybiByYXdQZW07XG4gICAgfVxuXG4gICAgY29uc3QgZGVjb21wb3NlZEtleSA9IGRlY29tcG9zZVByaXZhdGVLZXkoYFxcbiR7cmF3UGVtfVxcbmAsIHtcbiAgICAgIGZvcm1hdDogXCJwa2NzOC1wZW1cIixcbiAgICB9KTtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgZGVjb21wb3NlZEtleVtcImVuY3J5cHRpb25BbGdvcml0aG1cIl0gPSB7XG4gICAgICBrZXlEZXJpdmF0aW9uRnVuYzoge1xuICAgICAgICBpZDogXCJwYmtkZjJcIixcbiAgICAgICAgaXRlcmF0aW9uQ291bnQ6IDEwMDAwLCAvLyBUaGUgbnVtYmVyIG9mIGl0ZXJhdGlvbnNcbiAgICAgICAga2V5TGVuZ3RoOiAzMiwgLy8gQXV0b21hdGljLCBiYXNlZCBvbiB0aGUgYGVuY3J5cHRpb25TY2hlbWVgXG4gICAgICAgIHByZjogXCJobWFjLXdpdGgtc2hhMjU2XCIsIC8vIFRoZSBwc2V1ZG8tcmFuZG9tIGZ1bmN0aW9uXG4gICAgICB9LFxuICAgICAgZW5jcnlwdGlvblNjaGVtZTogXCJhZXMyNTYtY2JjXCIsXG4gICAgfTtcbiAgICByZXR1cm4gY29tcG9zZVByaXZhdGVLZXkoZGVjb21wb3NlZEtleSwgeyBwYXNzd29yZCB9KS5yZXBsYWNlKC9cXG4kLywgXCJcIik7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgZXhwb3J0UHJpdmF0ZUtleUluQmFzZTY0VXJsKCk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgY29uc3QgcHJpdmF0ZUtleSA9IGF3YWl0IHRoaXMuZXhwb3J0UHJpdmF0ZUtleSgpO1xuICAgIGNvbnN0IGJ1ZmZlciA9IGV4dHJhY3RCdWZmZXIocHJpdmF0ZUtleSwgXCJwcml2YXRlXCIpO1xuICAgIHJldHVybiBidWZmZXJUb0Jhc2U2NFVybEVuY29kZWQoYnVmZmVyKTtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBleHBvcnRQdWJsaWNLZXkoKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICBpZiAoIXRoaXMuX3B1YmxpY0tleSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwicHVibGljIGtleSBpcyBub3QgaW5zdGFudGlhdGVkLlwiKTtcbiAgICB9XG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IHRoaXMuX2NyeXB0by5zdWJ0bGUuZXhwb3J0S2V5KFwic3BraVwiLCB0aGlzLl9wdWJsaWNLZXkpO1xuICAgIHJldHVybiBwZW1Gb3JtYXQoQnVmZmVyLmZyb20oZGF0YSksIFwicHVibGljXCIpO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIGV4cG9ydFB1YmxpY0tleUluQmFzZTY0VXJsKCk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgY29uc3QgcHVibGljS2V5ID0gYXdhaXQgdGhpcy5leHBvcnRQdWJsaWNLZXkoKTtcbiAgICBjb25zdCBidWZmZXIgPSBleHRyYWN0QnVmZmVyKHB1YmxpY0tleSwgXCJwdWJsaWNcIik7XG4gICAgcmV0dXJuIGJ1ZmZlclRvQmFzZTY0VXJsRW5jb2RlZChidWZmZXIpO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIHJzYUxhcmdlTWVzc2FnZUVuY3J5cHQobXNnOiBzdHJpbmcpOiBQcm9taXNlPEJ1ZmZlcj4ge1xuICAgIGlmICghdGhpcy5wdWJsaWNLZXkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcInB1YmxpYyBrZXkgaXMgbm90IHBhc3NlZCBwcm9wZXJseS5cIik7XG4gICAgfVxuICAgIGNvbnN0IGJ1ZmZlckRhdGEgPSBCdWZmZXIuZnJvbShtc2csIFwidXRmLThcIik7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGNvbnN0IGtleVNpemUgPSB0aGlzLnB1YmxpY0tleS5hbGdvcml0aG0ubW9kdWx1c0xlbmd0aCAvIDg7XG4gICAgY29uc3QgaGFzaFNpemUgPSAzMjsgLy8gQ2F1c2Ugc2hhMjU2IGlzIGFsd2F5cyAzMiBieXRlc1xuICAgIGNvbnN0IGJsb2NrU2l6ZSA9IGtleVNpemUgLSAyICogaGFzaFNpemUgLSAyOyAvLyBtYXhpbXVtIE9BRVAgYmxvY2sgc2l6ZVxuICAgIGNvbnN0IGxlbmd0aCA9IGJ1ZmZlckRhdGEubGVuZ3RoO1xuICAgIGxldCBudW1CbG9ja3MgPSBNYXRoLmZsb29yKGxlbmd0aCAvIGJsb2NrU2l6ZSk7XG4gICAgaWYgKGxlbmd0aCAlIGJsb2NrU2l6ZSAhPT0gMCkge1xuICAgICAgbnVtQmxvY2tzICs9IDE7XG4gICAgfVxuXG4gICAgbGV0IHJlcyA9IEJ1ZmZlci5hbGxvYyhrZXlTaXplICogbnVtQmxvY2tzKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bUJsb2NrczsgaSsrKSB7XG4gICAgICBsZXQgY3VycmVudFNpemUgPSBibG9ja1NpemU7XG4gICAgICBpZiAoYnVmZmVyRGF0YS5sZW5ndGggPCAoaSArIDEpICogYmxvY2tTaXplKSB7XG4gICAgICAgIGN1cnJlbnRTaXplID0gYnVmZmVyRGF0YS5sZW5ndGggLSBpICogYmxvY2tTaXplO1xuICAgICAgfVxuICAgICAgbGV0IGJsb2NrID0gYnVmZmVyRGF0YS5zbGljZShpICogYmxvY2tTaXplLCBpICogYmxvY2tTaXplICsgY3VycmVudFNpemUpO1xuICAgICAgY29uc3QgYnVmZmVyRW5jRGF0YSA9IGF3YWl0IHRoaXMuZW5jcnlwdChibG9jayk7XG4gICAgICBmb3IgKGxldCBqID0gaSAqIGtleVNpemU7IGogPCBpICoga2V5U2l6ZSArIGJ1ZmZlckVuY0RhdGEubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgcmVzW2pdID0gYnVmZmVyRW5jRGF0YVtqIC0gaSAqIGtleVNpemVdO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIHJzYUxhcmdlTWVzc2FnZURlY3J5cHQoY2lwaGVyOiBCdWZmZXIpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgIGlmICghdGhpcy5wcml2YXRlS2V5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJwcml2YXRlIGtleSBpcyBub3QgcGFzc2VkIHByb3Blcmx5LlwiKTtcbiAgICB9XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGNvbnN0IGtleVNpemUgPSB0aGlzLnByaXZhdGVLZXkuYWxnb3JpdGhtLm1vZHVsdXNMZW5ndGggLyA4O1xuICAgIGNvbnN0IGxlbmd0aCA9IGNpcGhlci5sZW5ndGg7XG4gICAgaWYgKGxlbmd0aCAlIGtleVNpemUgIT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQga2V5IHNpemVcIik7XG4gICAgfVxuXG4gICAgY29uc3QgbnVtQmxvY2tzID0gbGVuZ3RoIC8ga2V5U2l6ZTtcbiAgICBsZXQgcmVzID0gXCJcIjtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bUJsb2NrczsgaSsrKSB7XG4gICAgICBjb25zdCBibG9jayA9IGNpcGhlci5zbGljZShpICoga2V5U2l6ZSwgKGkgKyAxKSAqIGtleVNpemUpO1xuICAgICAgY29uc3QgcHQgPSBhd2FpdCB0aGlzLmRlY3J5cHQoYmxvY2spO1xuICAgICAgcmVzICs9IHB0O1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEVuY3J5cHRpb247XG4iLCJpbXBvcnQgeyBwa2kgfSBmcm9tIFwibm9kZS1mb3JnZVwiO1xuaW1wb3J0IHsgY29tcG9zZVB1YmxpY0tleSwgY29tcG9zZVByaXZhdGVLZXksIGRlY29tcG9zZVB1YmxpY0tleSwgZGVjb21wb3NlUHJpdmF0ZUtleSB9IGZyb20gJ0BjcmVkaWZ5L2NyeXB0by1rZXktY29tcG9zZXInO1xuaW1wb3J0IHtcbiAgYmFzZTY0VG9CYXNlNjRVcmxFbmNvZGVkLFxuICBiYXNlNjRVcmxUb0Jhc2U2NEVuY29kZWQsIGJhc2U2NFVybFRvQnVmZmVyLFxuICBidWZmZXJUb0Jhc2U2NFVybEVuY29kZWQsXG4gIGV4dHJhY3RCdWZmZXIsXG4gIHBlbUZvcm1hdFxufSBmcm9tIFwiLi91dGlsc1wiO1xuaW1wb3J0IHR5cGUgeyBTaWduaW5nIGFzIElTaWduaW5nIH0gZnJvbSBcIi4uL3R5cGVzL2luZGV4XCI7XG5cbmNsYXNzIFNpZ25pbmcgaW1wbGVtZW50cyBJU2lnbmluZyB7XG4gIHByaXZhdGUgX3ByaXZhdGVLZXk6IHBraS5lZDI1NTE5LktleTtcbiAgcHJpdmF0ZSBfcHVibGljS2V5OiBwa2kuZWQyNTUxOS5LZXk7XG5cbiAgcHVibGljIGdldCBwcml2YXRlS2V5KCk6IEJ1ZmZlciB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHRoaXMuX3ByaXZhdGVLZXkpO1xuICB9XG4gIHB1YmxpYyBnZXQgcHVibGljS2V5KCk6IEJ1ZmZlciB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHRoaXMuX3B1YmxpY0tleSk7XG4gIH1cblxuICBwdWJsaWMgZ2VuZXJhdGVLZXlQYWlyKCk6IHZvaWQge1xuICAgIGNvbnN0IGtleVBhaXIgPSBwa2kuZWQyNTUxOS5nZW5lcmF0ZUtleVBhaXIoKTtcbiAgICB0aGlzLl9wcml2YXRlS2V5ID0ga2V5UGFpci5wcml2YXRlS2V5O1xuICAgIHRoaXMuX3B1YmxpY0tleSA9IGtleVBhaXIucHVibGljS2V5O1xuICB9XG5cbiAgcHVibGljIGltcG9ydFNlZWQoc2VlZDogc3RyaW5nKTogdm9pZCB7XG4gICAgY29uc3QgYnl0ZXMgPSBiYXNlNjRVcmxUb0J1ZmZlcihzZWVkKTtcbiAgICBjb25zdCBrZXlQYWlyID0gcGtpLmVkMjU1MTkuZ2VuZXJhdGVLZXlQYWlyKHsgc2VlZDogYnl0ZXMgfSk7XG4gICAgdGhpcy5fcHJpdmF0ZUtleSA9IGtleVBhaXIucHJpdmF0ZUtleTtcbiAgICB0aGlzLl9wdWJsaWNLZXkgPSBrZXlQYWlyLnB1YmxpY0tleTtcbiAgfVxuXG4gIHB1YmxpYyBpbXBvcnRQcml2YXRlS2V5KHBlbTogc3RyaW5nLCBwYXNzd29yZD86IHN0cmluZyk6IHZvaWQge1xuICAgIGNvbnN0IGRlY29tcG9zZWRLZXkgPSBkZWNvbXBvc2VQcml2YXRlS2V5KGBcXG4ke3BlbX1cXG5gLCB7IHBhc3N3b3JkLCBmb3JtYXQ6IFwicGtjczgtcGVtXCIgfSk7XG4gICAgY29uc3Qgc2VlZCA9IGRlY29tcG9zZWRLZXkua2V5RGF0YS5zZWVkO1xuICAgIGNvbnN0IGtleVBhaXIgPSBwa2kuZWQyNTUxOS5nZW5lcmF0ZUtleVBhaXIoe3NlZWR9KTtcbiAgICB0aGlzLl9wcml2YXRlS2V5ID0ga2V5UGFpci5wcml2YXRlS2V5O1xuICAgIHRoaXMuX3B1YmxpY0tleSA9IGtleVBhaXIucHVibGljS2V5O1xuICB9XG5cbiAgcHVibGljIGltcG9ydFByaXZhdGVLZXlJbkJhc2U2NFVybChwZW06IHN0cmluZywgcGFzc3dvcmQ/OiBzdHJpbmcpOiB2b2lkIHtcbiAgICBjb25zdCBwZW1EYXRhID0gYmFzZTY0VXJsVG9CYXNlNjRFbmNvZGVkKHBlbSk7XG4gICAgY29uc3QgcCA9IHBlbUZvcm1hdChCdWZmZXIuZnJvbShwZW1EYXRhLCBcImJhc2U2NFwiKSwgXCJwcml2YXRlXCIpO1xuICAgIGNvbnN0IGRlY29tcG9zZWRLZXkgPSBkZWNvbXBvc2VQcml2YXRlS2V5KGBcXG4ke3B9XFxuYCwgeyBwYXNzd29yZCwgZm9ybWF0OiBcInBrY3M4LXBlbVwiIH0pO1xuICAgIGNvbnN0IHNlZWQgPSBkZWNvbXBvc2VkS2V5LmtleURhdGEuc2VlZDtcbiAgICBjb25zdCBrZXlQYWlyID0gcGtpLmVkMjU1MTkuZ2VuZXJhdGVLZXlQYWlyKHtzZWVkfSk7XG4gICAgdGhpcy5fcHJpdmF0ZUtleSA9IGtleVBhaXIucHJpdmF0ZUtleTtcbiAgICB0aGlzLl9wdWJsaWNLZXkgPSBrZXlQYWlyLnB1YmxpY0tleTtcbiAgfVxuXG4gIHB1YmxpYyBpbXBvcnRQdWJsaWNLZXkocGVtOiBzdHJpbmcpOiB2b2lkIHtcbiAgICBjb25zdCBkZWNvbXBvc2VkS2V5ID0gZGVjb21wb3NlUHVibGljS2V5KGBcXG4ke3BlbX1cXG5gKTtcbiAgICB0aGlzLl9wdWJsaWNLZXkgPSBkZWNvbXBvc2VkS2V5LmtleURhdGEuYnl0ZXM7XG4gIH1cblxuICBwdWJsaWMgaW1wb3J0UHVibGljS2V5SW5CYXNlNjRVcmwocGVtOiBzdHJpbmcpOiB2b2lkIHtcbiAgICBjb25zdCBwZW1EYXRhID0gYmFzZTY0VXJsVG9CYXNlNjRFbmNvZGVkKHBlbSk7XG4gICAgY29uc3QgcCA9IHBlbUZvcm1hdChCdWZmZXIuZnJvbShwZW1EYXRhLCBcImJhc2U2NFwiKSwgXCJwdWJsaWNcIik7XG4gICAgY29uc3QgZGVjb21wb3NlZEtleSA9IGRlY29tcG9zZVB1YmxpY0tleShgXFxuJHtwfVxcbmApO1xuICAgIHRoaXMuX3B1YmxpY0tleSA9IGRlY29tcG9zZWRLZXkua2V5RGF0YS5ieXRlcztcbiAgfVxuXG4gIHB1YmxpYyBzaWduKG1lc3NhZ2U6IHN0cmluZywgb3B0aW9uPzogeyBpbnB1dD86IFwiYmFzZTY0XCIgfCBcInV0ZjhcIiB8IFwiaGV4XCIsIG91dHB1dD86IFwiYmFzZTY0XCIgfCBcInV0ZjhcIiB8IFwiaGV4XCIgfSApOiBzdHJpbmcge1xuICAgIGlmICghdGhpcy5fcHJpdmF0ZUtleSkgdGhyb3cgbmV3IEVycm9yKFwiUHJpdmF0ZSBrZXkgaXMgbm90IHNldCB5ZXQuXCIpO1xuICAgIGxldCBkZWNvZGVkID0gYmFzZTY0VXJsVG9CdWZmZXIobWVzc2FnZSk7XG4gICAgaWYgKG9wdGlvbj8uaW5wdXQgPT09IFwiYmFzZTY0XCIpIHsgZGVjb2RlZCA9IEJ1ZmZlci5mcm9tKG1lc3NhZ2UsIFwiYmFzZTY0XCIpIH1cbiAgICBpZiAob3B0aW9uPy5pbnB1dCA9PT0gXCJ1dGY4XCIpIHsgZGVjb2RlZCA9IEJ1ZmZlci5mcm9tKG1lc3NhZ2UpIH1cbiAgICBpZiAob3B0aW9uPy5pbnB1dCA9PT0gXCJoZXhcIikgeyBkZWNvZGVkID0gQnVmZmVyLmZyb20obWVzc2FnZSwgXCJoZXhcIikgfVxuICAgIGxldCBiYXNlNjQgPSBwa2kuZWQyNTUxOS5zaWduKHsgbWVzc2FnZTogZGVjb2RlZCwgZW5jb2Rpbmc6IFwiYmluYXJ5XCIsIHByaXZhdGVLZXk6IHRoaXMuX3ByaXZhdGVLZXkgfSkudG9TdHJpbmcoXCJiYXNlNjRcIik7XG5cbiAgICBpZiAoYmFzZTY0LmluY2x1ZGVzKFwiLFwiKSkge1xuICAgICAgLy8gRklYTUU6IE5leHQuanMgd2FzIG5vdCB3b3JraW5nIHdlbGwgd2l0aCBwa2kuZWQyNTUxOS5zaWduJ3MgZm9ybWF0XG4gICAgICBiYXNlNjQgPSBCdWZmZXIuZnJvbShiYXNlNjQuc3BsaXQoXCIsXCIpLm1hcChOdW1iZXIpKS50b1N0cmluZyhcImJhc2U2NFwiKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9uPy5vdXRwdXQgPT09IFwiYmFzZTY0XCIpIHtcbiAgICAgIHJldHVybiBiYXNlNjQ7XG4gICAgfVxuICAgIGlmIChvcHRpb24/Lm91dHB1dCA9PT0gXCJ1dGY4XCIpIHtcbiAgICAgIHJldHVybiBCdWZmZXIuZnJvbShiYXNlNjQsIFwiYmFzZTY0XCIpLnRvU3RyaW5nKFwidXRmOFwiKVxuICAgIH1cbiAgICBpZiAob3B0aW9uPy5vdXRwdXQgPT09IFwiaGV4XCIpIHtcbiAgICAgIHJldHVybiBCdWZmZXIuZnJvbShiYXNlNjQsIFwiYmFzZTY0XCIpLnRvU3RyaW5nKFwiaGV4XCIpXG4gICAgfVxuICAgIC8vIERlZmF1bHQgaXMgYmFzZTY0VVJMIGVuY29kZWQgc3RyaW5nXG4gICAgcmV0dXJuIGJhc2U2NFRvQmFzZTY0VXJsRW5jb2RlZChiYXNlNjQpO1xuICB9XG5cbiAgdmVyaWZ5KG1lc3NhZ2U6IHN0cmluZywgc2lnbmF0dXJlOiBzdHJpbmcsIG9wdGlvbj86IHsgZW5jb2RlOiBcImJhc2U2NFwiIHwgXCJiYXNlNjRVcmxcIiB9KTogYm9vbGVhbiB7XG4gICAgaWYgKCF0aGlzLl9wdWJsaWNLZXkpIHRocm93IG5ldyBFcnJvcihcIlB1YmxpYyBrZXkgaXMgbm90IHNldCB5ZXQuXCIpO1xuICAgIGxldCBzaWcgPSBcIlwiO1xuICAgIGlmIChvcHRpb24/LmVuY29kZSA9PT0gXCJiYXNlNjRcIikge1xuICAgICAgc2lnID0gc2lnbmF0dXJlO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBEZWZhdWx0IGlzIGJhc2U2NFVSTCBlbmNvZGVkIHN0cmluZ1xuICAgICAgc2lnID0gYmFzZTY0VXJsVG9CYXNlNjRFbmNvZGVkKHNpZ25hdHVyZSk7XG4gICAgfVxuICAgIHJldHVybiBwa2kuZWQyNTUxOS52ZXJpZnkoe1xuICAgICAgbWVzc2FnZSxcbiAgICAgIGVuY29kaW5nOiBcImJpbmFyeVwiLFxuICAgICAgc2lnbmF0dXJlOiBCdWZmZXIuZnJvbShzaWcsIFwiYmFzZTY0XCIpLFxuICAgICAgcHVibGljS2V5OiB0aGlzLl9wdWJsaWNLZXlcbiAgICB9KVxuICB9XG5cbiAgcHVibGljIGV4cG9ydFByaXZhdGVLZXkocGFzc3dvcmQ/OiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIGlmICghdGhpcy5fcHJpdmF0ZUtleSkgeyB0aHJvdyBuZXcgRXJyb3IoXCJwcml2YXRlIGtleSBpcyBub3QgaW5zdGFudGlhdGVkLlwiKSB9XG5cbiAgICBjb25zdCBkZWNvbXBvc2VkID0ge1xuICAgICAgZm9ybWF0OiAncGtjczgtcGVtJyxcbiAgICAgIGtleUFsZ29yaXRobTogeyBpZDogJ2VkMjU1MTknIH0sXG4gICAgICBrZXlEYXRhOiB7XG4gICAgICAgIHNlZWQ6IHRoaXMuX3ByaXZhdGVLZXkuc2xpY2UoMCwgMzIpLFxuICAgICAgfSxcbiAgICB9O1xuICAgIGlmIChwYXNzd29yZCkge1xuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgZGVjb21wb3NlZFtcImVuY3J5cHRpb25BbGdvcml0aG1cIl0gPSB7XG4gICAgICAgIGtleURlcml2YXRpb25GdW5jOiB7XG4gICAgICAgICAgaWQ6ICdwYmtkZjInLFxuICAgICAgICAgIGl0ZXJhdGlvbkNvdW50OiAxMDAwMCwgIC8vIFRoZSBudW1iZXIgb2YgaXRlcmF0aW9uc1xuICAgICAgICAgIGtleUxlbmd0aDogMzIsIC8vIEF1dG9tYXRpYywgYmFzZWQgb24gdGhlIGBlbmNyeXB0aW9uU2NoZW1lYFxuICAgICAgICAgIHByZjogJ2htYWMtd2l0aC1zaGEyNTYnICAvLyBUaGUgcHNldWRvLXJhbmRvbSBmdW5jdGlvblxuICAgICAgICB9LFxuICAgICAgICBlbmNyeXB0aW9uU2NoZW1lOiAnYWVzMjU2LWNiYycsXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjb21wb3NlUHJpdmF0ZUtleShkZWNvbXBvc2VkLCB7IHBhc3N3b3JkIH0pLnJlcGxhY2UoL1xcbiQvLCBcIlwiKTtcbiAgfVxuXG4gIHB1YmxpYyBleHBvcnRQdWJsaWNLZXkoKTogc3RyaW5nIHtcbiAgICBpZiAoIXRoaXMuX3B1YmxpY0tleSkgeyB0aHJvdyBuZXcgRXJyb3IoXCJwdWJsaWMga2V5IGlzIG5vdCBpbnN0YW50aWF0ZWQuXCIpIH1cbiAgICBjb25zdCBkZWNvbXBvc2VkID0ge1xuICAgICAgZm9ybWF0OiAnc3BraS1wZW0nLFxuICAgICAga2V5QWxnb3JpdGhtOiB7IGlkOiAnZWQyNTUxOScgfSxcbiAgICAgIGtleURhdGE6IHtcbiAgICAgICAgYnl0ZXM6IHRoaXMuX3B1YmxpY0tleSxcbiAgICAgIH0sXG4gICAgfTtcbiAgICByZXR1cm4gY29tcG9zZVB1YmxpY0tleShkZWNvbXBvc2VkKS5yZXBsYWNlKC9cXG4kLywgXCJcIik7XG4gIH1cblxuICBwdWJsaWMgZXhwb3J0UHJpdmF0ZUtleUluQmFzZTY0VXJsKCk6IHN0cmluZyB7XG4gICAgY29uc3QgcHJpdlBlbSA9IHRoaXMuZXhwb3J0UHJpdmF0ZUtleSgpO1xuICAgIGNvbnN0IGJ1ZmZlciA9IGV4dHJhY3RCdWZmZXIocHJpdlBlbSwgXCJwcml2YXRlXCIpO1xuICAgIHJldHVybiBidWZmZXJUb0Jhc2U2NFVybEVuY29kZWQoYnVmZmVyKTtcbiAgfVxuXG4gIHB1YmxpYyBleHBvcnRQdWJsaWNLZXlJbkJhc2U2NFVybCgpOiBzdHJpbmcge1xuICAgIGNvbnN0IHB1YlBlbSA9IHRoaXMuZXhwb3J0UHVibGljS2V5KCk7XG4gICAgY29uc3QgcHViQnVmZmVyID0gZXh0cmFjdEJ1ZmZlcihwdWJQZW0sIFwicHVibGljXCIpO1xuICAgIHJldHVybiBidWZmZXJUb0Jhc2U2NFVybEVuY29kZWQocHViQnVmZmVyKTtcbiAgfVxuXG4gIHB1YmxpYyBleHBvcnRTZWVkKCk6IHN0cmluZyB7XG4gICAgY29uc3Qgc2VlZERhdGEgPSB0aGlzLl9wcml2YXRlS2V5LnNsaWNlKDAsIDMyKTtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgcmV0dXJuIGJ1ZmZlclRvQmFzZTY0VXJsRW5jb2RlZChzZWVkRGF0YSk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgU2lnbmluZztcbiIsImltcG9ydCB0eXBlIHsgSldUSGVhZGVyLCBKV1RQYXlsb2FkLCBKV1RUeXBlIH0gZnJvbSBcIi4uL3R5cGVzXCI7XG5pbXBvcnQgU2lnbmluZyBmcm9tIFwiQC9zaWduaW5nXCI7XG5pbXBvcnQge1xuICBiYXNlNjRUb0Jhc2U2NFVybEVuY29kZWQsXG4gIGJhc2U2NFVybFRvQmFzZTY0RW5jb2RlZCxcbiAgZ2VuZXJhdGVDb21taXRtZW50LFxuICBzaGEyNTYsXG4gIHVuaWZ5SnNvbkRhdGEsXG59IGZyb20gXCIuL3V0aWxzXCI7XG5pbXBvcnQgRW5jcnlwdGlvbiBmcm9tIFwiLi9lbmNyeXB0aW9uXCI7XG5cbmNvbnN0IGRlY29kZVRva2VuQ29tcG9uZW50ID0gKGJhc2U2NFVybDogc3RyaW5nKTogb2JqZWN0ID0+IHtcbiAgY29uc3QgYmFzZTY0ID0gYmFzZTY0VXJsVG9CYXNlNjRFbmNvZGVkKGJhc2U2NFVybCk7XG4gIHJldHVybiBKU09OLnBhcnNlKEJ1ZmZlci5mcm9tKGJhc2U2NCwgXCJiYXNlNjRcIikudG9TdHJpbmcoXCJiaW5hcnlcIikpO1xufTtcblxuY29uc3QgZW5jb2RlVG9rZW5Db21wb25lbnQgPSAoanNvbjogb2JqZWN0KTogc3RyaW5nID0+IHtcbiAgY29uc3QgYmFzZTY0RW5jb2RlZCA9IEJ1ZmZlci5mcm9tKEpTT04uc3RyaW5naWZ5KGpzb24pKS50b1N0cmluZyhcImJhc2U2NFwiKTtcbiAgcmV0dXJuIGJhc2U2NFRvQmFzZTY0VXJsRW5jb2RlZChiYXNlNjRFbmNvZGVkKTtcbn07XG5cbmNvbnN0IGNvbXBvc2VNZXNzYWdlID0gKGhlYWRlcjogSldUSGVhZGVyLCBwYXlsb2FkOiBKV1RQYXlsb2FkKTogc3RyaW5nID0+IHtcbiAgcmV0dXJuIGAke2VuY29kZVRva2VuQ29tcG9uZW50KGhlYWRlcil9LiR7ZW5jb2RlVG9rZW5Db21wb25lbnQocGF5bG9hZCl9YDtcbn07XG5cbmV4cG9ydCBjb25zdCBwYXJzZUp3dCA9ICh0b2tlbjogc3RyaW5nKTogSldUVHlwZSA9PiB7XG4gIGNvbnN0IFtoZWFkZXJFbmNvZGVkLCBwYXlsb2FkRW5jb2RlZCwgc2lnbmF0dXJlXSA9IHRva2VuLnNwbGl0KFwiLlwiKTtcbiAgY29uc3QgW2hlYWRlciwgcGF5bG9hZF0gPSBbaGVhZGVyRW5jb2RlZCwgcGF5bG9hZEVuY29kZWRdLm1hcChcbiAgICBkZWNvZGVUb2tlbkNvbXBvbmVudFxuICApO1xuICAvLyBAdHMtaWdub3JlXG4gIGlmICghaGVhZGVyW1wiYWxnXCJdIHx8ICFoZWFkZXJbXCJ0eXBcIl0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJIZWFkZXIgZm9ybWF0IGlzIG5vdCBjb3JyZWN0LlwiKTtcbiAgfVxuICAvLyBAdHMtaWdub3JlXG4gIHJldHVybiB7IGhlYWRlciwgaGVhZGVyRW5jb2RlZCwgcGF5bG9hZCwgcGF5bG9hZEVuY29kZWQsIHNpZ25hdHVyZSB9O1xufTtcblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSBKV1QuXG4gKiBAcGFyYW0gc2lnbmluZ1xuICogQHBhcmFtIHBheWxvYWRcbiAqL1xuZXhwb3J0IGNvbnN0IGdlbmVyYXRlSnd0ID0gKHNpZ25pbmc6IFNpZ25pbmcsIHBheWxvYWQ/OiBhbnkpOiBzdHJpbmcgPT4ge1xuICAvLyBOT1RFOiBBZGRlZCBgLSA2MGAganVzdCBpbiBjYXNlIGEgdGltZXN0YW1wIGluIHRoZSBCRSBpcyBub3Qgd29ya2luZyBwcm9wZXJseS5cbiAgY29uc3QgdGltZXN0YW1wID0gTnVtYmVyKChuZXcgRGF0ZSgpLmdldFRpbWUoKSAvIDEwMDApLnRvRml4ZWQoMCkpIC0gNjA7XG4gIGNvbnN0IGhlYWRlciA9IHtcbiAgICBhbGc6IFwiRWREU0FcIixcbiAgICB0eXA6IFwiSldUXCIsXG4gIH07XG4gIGNvbnN0IHAgPSBwYXlsb2FkIHx8IHtcbiAgICBleHA6IHRpbWVzdGFtcCArIDYwICogNjAsXG4gICAgaWF0OiB0aW1lc3RhbXAsXG4gICAgc2lnbmluZ19rZXk6IHNpZ25pbmcuZXhwb3J0UHVibGljS2V5KCksXG4gIH07XG4gIGNvbnN0IHNpZ25hdHVyZSA9IHNpZ25pbmcuc2lnbihjb21wb3NlTWVzc2FnZShoZWFkZXIsIHApLCB7IGlucHV0OiBcInV0ZjhcIiB9KTtcbiAgcmV0dXJuIGAke2VuY29kZVRva2VuQ29tcG9uZW50KGhlYWRlcil9LiR7ZW5jb2RlVG9rZW5Db21wb25lbnQoXG4gICAgcFxuICApfS4ke3NpZ25hdHVyZX1gO1xufTtcblxuLyoqXG4gKiBHZW5lcmF0ZXMgYW4gYXBwcm92YWwgdG9rZW5cbiAqIEBwYXJhbSBzaWduaW5nXG4gKiBAcGFyYW0gY2xpZW50SWRcbiAqIEBwYXJhbSBlbnRpdHlJZFxuICogQHBhcmFtIGFwcHJvdmVkU2NvcGVzXG4gKiBAcGFyYW0gb2ZmZXJDb2RlXG4gKi9cbmV4cG9ydCBjb25zdCBnZW5lcmF0ZUFwcHJvdmFsVG9rZW4gPSAoXG4gIHNpZ25pbmc6IFNpZ25pbmcsXG4gIGNsaWVudElkOiBzdHJpbmcsXG4gIGVudGl0eUlkOiBzdHJpbmcsXG4gIGFwcHJvdmVkU2NvcGVzOiBzdHJpbmdbXSxcbiAgb2ZmZXJDb2RlPzogc3RyaW5nXG4pID0+IHtcbiAgLy8gTk9URTogQWRkZWQgYC0gNjBgIGp1c3QgaW4gY2FzZSBhIHRpbWVzdGFtcCBpbiB0aGUgQkUgaXMgbm90IHdvcmtpbmcgcHJvcGVybHkuXG4gIGNvbnN0IHRpbWVzdGFtcCA9IE51bWJlcigobmV3IERhdGUoKS5nZXRUaW1lKCkgLyAxMDAwKS50b0ZpeGVkKDApKSAtIDYwO1xuICBjb25zdCBwYXlsb2FkID0ge1xuICAgIGNsaWVudF9pZDogY2xpZW50SWQsXG4gICAgaWF0OiB0aW1lc3RhbXAsXG4gICAgaXNzOiBlbnRpdHlJZCxcbiAgICBzY29wZXM6IGFwcHJvdmVkU2NvcGVzLmpvaW4oXCIgXCIpLFxuICB9O1xuICBpZiAob2ZmZXJDb2RlKSB7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHBheWxvYWRbXCJvZmZlcl9jb2RlXCJdID0gb2ZmZXJDb2RlO1xuICB9XG4gIHJldHVybiBnZW5lcmF0ZUp3dChzaWduaW5nLCBwYXlsb2FkKTtcbn07XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgY2xhaW0gdG9rZW4gYW5kIGEgY29tbWl0bWVudFxuICogQHBhcmFtIHNpZ25pbmdcbiAqIEBwYXJhbSBwcm92aWRlcklkXG4gKiBAcGFyYW0gZW50aXR5SWRcbiAqIEBwYXJhbSBzY29wZU5hbWVcbiAqIEBwYXJhbSBjbGFpbSAtIGNsYWltIG9iamVjdCB3aXRoIHJhdyB2YWx1ZXMuXG4gKiBAcmV0dXJucyB7IHRva2VuOiBzdHJpbmc7IGNvbW1pdG1lbnQ6IHN0cmluZyB9XG4gKi9cbmV4cG9ydCBjb25zdCBnZW5lcmF0ZUNsYWltVG9rZW4gPSAoXG4gIHNpZ25pbmc6IFNpZ25pbmcsXG4gIHByb3ZpZGVySWQ6IHN0cmluZyxcbiAgZW50aXR5SWQ6IHN0cmluZyxcbiAgc2NvcGVOYW1lOiBzdHJpbmcsXG4gIGNsYWltOiBvYmplY3RcbikgPT4ge1xuICAvLyBOT1RFOiBBZGRlZCBgLSA2MGAganVzdCBpbiBjYXNlIGEgdGltZXN0YW1wIGluIHRoZSBCRSBpcyBub3Qgd29ya2luZyBwcm9wZXJseS5cbiAgY29uc3QgdGltZXN0YW1wID0gTnVtYmVyKChuZXcgRGF0ZSgpLmdldFRpbWUoKSAvIDEwMDApLnRvRml4ZWQoMCkpIC0gNjA7XG4gIGNvbnN0IGNvbW1pdG1lbnQgPSBnZW5lcmF0ZUNvbW1pdG1lbnQoKTtcbiAgY29uc3Qga2V5ID0gc2NvcGVOYW1lLmluY2x1ZGVzKFwiOlwiKVxuICAgID8gYCR7c2NvcGVOYW1lfTpjb21taXRtZW50YFxuICAgIDogYCR7c2NvcGVOYW1lfV9jb21taXRtZW50YDtcbiAgY29uc3Qgc2NvcGVIYXNoID0gc2hhMjU2KFxuICAgIHVuaWZ5SnNvbkRhdGEoe1xuICAgICAgLi4uY2xhaW0sXG4gICAgICBba2V5XTogY29tbWl0bWVudCxcbiAgICB9KVxuICApO1xuICBjb25zdCBwYXlsb2FkID0ge1xuICAgIGlhdDogdGltZXN0YW1wLFxuICAgIGlzczogcHJvdmlkZXJJZCxcbiAgICB1c2VyX2lkOiBlbnRpdHlJZCxcbiAgICBzY29wZV9uYW1lOiBzY29wZU5hbWUsXG4gICAgc2NvcGVfaGFzaDogc2NvcGVIYXNoLFxuICB9O1xuICBjb25zdCB0b2tlbiA9IGdlbmVyYXRlSnd0KHNpZ25pbmcsIHBheWxvYWQpO1xuICByZXR1cm4geyB0b2tlbiwgY29tbWl0bWVudCB9O1xufTtcblxuLyoqXG4gKiBHZW5lcmF0ZSBkaXNidXJzZW1lbnQgdG9rZW5cbiAqIEBwYXJhbSBzaWduaW5nXG4gKiBAcGFyYW0gcHJvdmlkZXJJZFxuICogQHBhcmFtIGVudGl0eUlkXG4gKiBAcGFyYW0gY2xhaW1PYmpcbiAqICBmb3JtYXQ6IHsgY2xhaW1zW2tleUFdOiB7IFtkaXNidXJzZW1lbnRfa2V5XToge30sIFtjb21taXRtZW50X2tleV06IHt9IH0sIGNsYWltc1trZXlCXSAuLi4gfVxuICogQHBhcmFtIHB1YmxpY0tleVxuICogQHJldHVybnMgc3RyaW5nXG4gKi9cbmV4cG9ydCBjb25zdCBnZW5lcmF0ZURpc2J1cnNlbWVudFRva2VuID0gYXN5bmMgKFxuICBzaWduaW5nOiBTaWduaW5nLFxuICBwcm92aWRlcklkOiBzdHJpbmcsXG4gIGVudGl0eUlkOiBzdHJpbmcsXG4gIGNsYWltT2JqOiB7IFtrZXk6IHN0cmluZ106IGFueSB9LFxuICBwdWJsaWNLZXk/OiBzdHJpbmdcbikgPT4ge1xuICBsZXQgZGlzYnVyc2VtZW50Q2xhaW1Db21wb3NlT2JqOiB7IFtrZXk6IHN0cmluZ106IGFueSB9ID0ge30sXG4gICAgZW5jcnlwdGVkQ29udGVudHM6IHN0cmluZ1tdO1xuICAvLyBOT1RFOiBBZGRlZCBgLSA2MGAganVzdCBpbiBjYXNlIGEgdGltZXN0YW1wIGluIHRoZSBCRSBpcyBub3Qgd29ya2luZyBwcm9wZXJseS5cbiAgY29uc3QgdGltZXN0YW1wID0gTnVtYmVyKChuZXcgRGF0ZSgpLmdldFRpbWUoKSAvIDEwMDApLnRvRml4ZWQoMCkpIC0gNjA7XG5cbiAgaWYgKHB1YmxpY0tleSkge1xuICAgIGNvbnN0IGVuYyA9IG5ldyBFbmNyeXB0aW9uKCk7XG4gICAgaWYgKHB1YmxpY0tleS5zdGFydHNXaXRoKFwiTVwiKSkge1xuICAgICAgYXdhaXQgZW5jLmltcG9ydFB1YmxpY0tleUluQmFzZTY0VXJsKHB1YmxpY0tleSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGF3YWl0IGVuYy5pbXBvcnRQdWJsaWNLZXkocHVibGljS2V5KTtcbiAgICB9XG5cbiAgICBlbmNyeXB0ZWRDb250ZW50cyA9IGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgT2JqZWN0LmtleXMoY2xhaW1PYmopLm1hcCgoc2NvcGVLZXkpID0+IHtcbiAgICAgICAgaWYgKCFjbGFpbU9ialtzY29wZUtleV1bc2NvcGVLZXldKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGlzYnVyc2VtZW50IGNsYWltIG9iamVjdCBpcyBub3QgdmFsaWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVuYy5lbmNyeXB0U3RyaW5nVG9CYXNlNjRVcmxTdHJpbmcoXG4gICAgICAgICAgY2xhaW1PYmpbc2NvcGVLZXldW3Njb3BlS2V5XS5jb250ZW50XG4gICAgICAgICk7XG4gICAgICB9KVxuICAgICk7XG4gIH1cblxuICAvLyBUcmFuc2Zvcm0gY2xhaW0gb2JqXG4gIE9iamVjdC5rZXlzKGNsYWltT2JqKS5mb3JFYWNoKChzY29wZUtleSwgaW5kZXgpID0+IHtcbiAgICBjb25zdCBjbGFpbSA9IGNsYWltT2JqW3Njb3BlS2V5XTtcblxuICAgIGlmICghY2xhaW1bc2NvcGVLZXldKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEaXNidXJzZW1lbnQgY2xhaW0gb2JqZWN0IGlzIG5vdCB2YWxpZFwiKTtcbiAgICB9XG5cbiAgICBjb25zdCBjb250ZW50ID0gcHVibGljS2V5XG4gICAgICA/IGVuY3J5cHRlZENvbnRlbnRzW2luZGV4XVxuICAgICAgOiBjbGFpbVtzY29wZUtleV0uY29udGVudDtcblxuICAgIGRpc2J1cnNlbWVudENsYWltQ29tcG9zZU9ialtzY29wZUtleV0gPSB7XG4gICAgICBjb250ZW50X3R5cGU6IGNsYWltW3Njb3BlS2V5XS5jb250ZW50X3R5cGUsXG4gICAgICBjb250ZW50LFxuICAgIH07XG4gICAgZGlzYnVyc2VtZW50Q2xhaW1Db21wb3NlT2JqW2Ake3Njb3BlS2V5fTpjb21taXRtZW50YF0gPVxuICAgICAgY2xhaW1bYCR7c2NvcGVLZXl9OmNvbW1pdG1lbnRgXTtcbiAgfSk7XG5cbiAgLy8gQ3VycmVudCB3ZSB3aWxsIHVzZSByYXcgYmFzZTY0LCBub3QgY2hhbmdlIHRoZSBtZXRob2QgZW5jcnlwdFxuICBjb25zdCBwYXlsb2FkID0ge1xuICAgIGlhdDogdGltZXN0YW1wLFxuICAgIGlzczogcHJvdmlkZXJJZCxcbiAgICB1c2VyX2lkOiBlbnRpdHlJZCxcbiAgICAuLi5kaXNidXJzZW1lbnRDbGFpbUNvbXBvc2VPYmosXG4gIH07XG4gIGNvbnN0IHRva2VuID0gZ2VuZXJhdGVKd3Qoc2lnbmluZywgcGF5bG9hZCk7XG4gIHJldHVybiB0b2tlbjtcbn07XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgcmVxdWVzdCB0b2tlblxuICogQHBhcmFtIHNpZ25pbmdcbiAqIEBwYXJhbSBlbmNyeXB0aW9uUHVibGljS2V5IC0gQmFzZTY0IFVSTCBlbmNvZGVkIHB1YmxpYyBrZXlcbiAqIEBwYXJhbSBzY29wZXMgLSBSZXF1ZXN0ZWQgc2NvcGVzIGxpc3QuXG4gKiBAcGFyYW0gb2ZmZXJDb2RlXG4gKi9cbmV4cG9ydCBjb25zdCBnZW5lcmF0ZVJlcXVlc3RUb2tlbiA9IChcbiAgc2lnbmluZzogU2lnbmluZyxcbiAgZW5jcnlwdGlvblB1YmxpY0tleTogc3RyaW5nLFxuICBzY29wZXM6IHN0cmluZ1tdLFxuICBvZmZlckNvZGU/OiBzdHJpbmdcbikgPT4ge1xuICBpZiAoIXNjb3Blcy5pbmNsdWRlcyhcIm9wZW5pZFwiKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIm9wZW5pZCBpcyByZXF1aXJlZC5cIik7XG4gIH1cbiAgLy8gTk9URTogQWRkZWQgYC0gNjBgIGp1c3QgaW4gY2FzZSBhIHRpbWVzdGFtcCBpbiB0aGUgQkUgaXMgbm90IHdvcmtpbmcgcHJvcGVybHkuXG4gIGNvbnN0IHRpbWVzdGFtcCA9IE51bWJlcigobmV3IERhdGUoKS5nZXRUaW1lKCkgLyAxMDAwKS50b0ZpeGVkKDApKSAtIDYwO1xuICBjb25zdCBmb3JtYXR0ZWRTY29wZXMgPSBzY29wZXMuam9pbihcIiBcIik7XG4gIGNvbnN0IHBheWxvYWQgPSB7XG4gICAgZW5jcnlwdGlvbl9wdWJsaWNfa2V5OiBlbmNyeXB0aW9uUHVibGljS2V5LFxuICAgIGlhdDogdGltZXN0YW1wLFxuICAgIHNjb3BlczogZm9ybWF0dGVkU2NvcGVzLFxuICB9O1xuICBpZiAob2ZmZXJDb2RlKSB7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHBheWxvYWRbXCJvZmZlcl9jb2RlXCJdID0gb2ZmZXJDb2RlO1xuICB9XG4gIHJldHVybiBnZW5lcmF0ZUp3dChzaWduaW5nLCBwYXlsb2FkKTtcbn07XG5cbi8qKlxuICogR2VuZXJhdGVzIGFuIGlkZW50aXR5IHRva2VuXG4gKiBAcGFyYW0gc2lnbmluZ1xuICogQHBhcmFtIGVudGl0eUlkXG4gKiBAcGFyYW0gaWRlbnRpdHlTb3VyY2VcbiAqIEBwYXJhbSBpZGVudGl0eUhhc2hcbiAqL1xuZXhwb3J0IGNvbnN0IGdlbmVyYXRlSWRlbnRpdHlUb2tlbiA9IChcbiAgc2lnbmluZzogU2lnbmluZyxcbiAgZW50aXR5SWQ6IHN0cmluZyxcbiAgaWRlbnRpdHlTb3VyY2U6IHN0cmluZyxcbiAgaWRlbnRpdHlIYXNoOiBzdHJpbmdcbikgPT4ge1xuICAvLyBOT1RFOiBBZGRlZCBgLSA2MGAganVzdCBpbiBjYXNlIGEgdGltZXN0YW1wIGluIHRoZSBCRSBpcyBub3Qgd29ya2luZyBwcm9wZXJseS5cbiAgY29uc3QgdGltZXN0YW1wID0gTnVtYmVyKChuZXcgRGF0ZSgpLmdldFRpbWUoKSAvIDEwMDApLnRvRml4ZWQoMCkpIC0gNjA7XG4gIGNvbnN0IHBheWxvYWQgPSB7XG4gICAgaWF0OiB0aW1lc3RhbXAsXG4gICAgaXNzOiBlbnRpdHlJZCxcbiAgICBpZGVudGl0eV9zb3VyY2U6IGlkZW50aXR5U291cmNlLFxuICAgIGlkZW50aXR5X2hhc2g6IGlkZW50aXR5SGFzaCxcbiAgfTtcbiAgcmV0dXJuIGdlbmVyYXRlSnd0KHNpZ25pbmcsIHBheWxvYWQpO1xufTtcblxuZXhwb3J0IGNvbnN0IHZlcmlmeUp3dCA9IChqd3Q6IEpXVFR5cGUsIHNpZ25pbmc6IFNpZ25pbmcpOiBib29sZWFuID0+IHtcbiAgY29uc3QgbWVzc2FnZSA9IGAke2p3dC5oZWFkZXJFbmNvZGVkfS4ke2p3dC5wYXlsb2FkRW5jb2RlZH1gO1xuICByZXR1cm4gc2lnbmluZy52ZXJpZnkobWVzc2FnZSwgand0LnNpZ25hdHVyZSk7XG59O1xuIiwiLy8gQHRzLWlnbm9yZVxuaW1wb3J0ICogYXMgSERLZXkgZnJvbSBcImhka2V5XCI7XG5pbXBvcnQgKiBhcyBiaXAzOSBmcm9tIFwiYmlwMzlcIjtcbmltcG9ydCAqIGFzIHdpZiBmcm9tIFwid2lmXCI7XG5pbXBvcnQgKiBhcyBlbGxpcHRpYyBmcm9tIFwiZWxsaXB0aWNcIjtcbmltcG9ydCB7IFByaXZhdGVLZXksIFB1YmxpY0tleSB9IGZyb20gXCJlb3Nqcy9kaXN0L2Vvc2pzLWpzc2lnXCI7XG5pbXBvcnQge1xuICBiYXNlNjRUb0JpbmFyeSxcbiAgYmluYXJ5VG9CYXNlNTgsXG4gIEtleVR5cGUsXG4gIHB1YmxpY0tleURhdGFTaXplLFxuICBzdHJpbmdUb1B1YmxpY0tleSxcbn0gZnJvbSBcImVvc2pzL2Rpc3QvZW9zanMtbnVtZXJpY1wiO1xuaW1wb3J0IHR5cGUgeyBDb2luVHlwZSwgV2FsbGV0IGFzIElXYWxsZXQgfSBmcm9tIFwiLi4vdHlwZXNcIjtcblxuY29uc3QgcmlwZW1kMTYwID0gcmVxdWlyZShcImVvc2pzL2Rpc3QvcmlwZW1kXCIpLlJJUEVNRDE2MC5oYXNoIGFzIChcbiAgYTogVWludDhBcnJheVxuKSA9PiBBcnJheUJ1ZmZlcjtcbmNvbnN0IGVjZHNhID0gbmV3IGVsbGlwdGljLmVjKFwic2VjcDI1NmsxXCIpO1xuXG5jbGFzcyBXYWxsZXQgaW1wbGVtZW50cyBJV2FsbGV0IHtcbiAgcHJpdmF0ZSByZWFkb25seSBtbmVtb25pYzogc3RyaW5nO1xuICBwcml2YXRlIG1hc3Rlck5vZGU6IEhES2V5O1xuXG4gIHB1YmxpYyBjb25zdHJ1Y3RvcihtbmVtb25pYzogc3RyaW5nKSB7XG4gICAgaWYgKG1uZW1vbmljLnNwbGl0KFwiIFwiKS5sZW5ndGggIT09IDEyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNbmVtb25pYyBmb3JtYXQgaXMgbm90IGNvcnJlY3RcIik7XG4gICAgfVxuICAgIHRoaXMubW5lbW9uaWMgPSBtbmVtb25pYztcbiAgICBjb25zdCBzZWVkOiBCdWZmZXIgPSBiaXAzOS5tbmVtb25pY1RvU2VlZFN5bmModGhpcy5tbmVtb25pYyk7XG4gICAgdGhpcy5tYXN0ZXJOb2RlID0gSERLZXkuZnJvbU1hc3RlclNlZWQoc2VlZCk7XG4gIH1cblxuICBwdWJsaWMgc3RhdGljIGNyZWF0ZSgpOiBXYWxsZXQge1xuICAgIGNvbnN0IG0gPSBiaXAzOS5nZW5lcmF0ZU1uZW1vbmljKCk7XG4gICAgcmV0dXJuIG5ldyBXYWxsZXQobSk7XG4gIH1cblxuICBwdWJsaWMgZ2V0TW5lbW9uaWMoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5tbmVtb25pYztcbiAgfVxuXG4gIHB1YmxpYyBnZXRNYXN0ZXJQcml2YXRlS2V5KCk6IHN0cmluZyB7XG4gICAgY29uc3QgbWFzdGVyUHJpdmF0ZUtleSA9IHdpZi5lbmNvZGUoMTI4LCB0aGlzLm1hc3Rlck5vZGUucHJpdmF0ZUtleSwgdHJ1ZSk7XG4gICAgLy8gY29uc29sZS5sb2coYD09PiBnZXRNYXN0ZXJQcml2YXRlS2V5IDogJHttYXN0ZXJQcml2YXRlS2V5fWApO1xuICAgIHJldHVybiBtYXN0ZXJQcml2YXRlS2V5O1xuICB9XG5cbiAgcHVibGljIGdldE1hc3RlclB1YmxpY0tleSgpOiBzdHJpbmcge1xuICAgIGNvbnN0IG1hc3RlclB1YmxpY0tleSA9IHRoaXMubWFzdGVyTm9kZS5wdWJsaWNLZXkudG9TdHJpbmcoXCJoZXhcIik7XG4gICAgLy8gY29uc29sZS5sb2coYD09PiBnZXRNYXN0ZXJQdWJsaWNLZXkgOiAke21hc3RlclB1YmxpY0tleX1gKTtcbiAgICByZXR1cm4gbWFzdGVyUHVibGljS2V5O1xuICB9XG5cbiAgcHVibGljIGdldEVPU1ByaXZhdGVLZXkoKTogc3RyaW5nIHtcbiAgICBjb25zdCBjaGlsZE5vZGUgPSB0aGlzLm1hc3Rlck5vZGUuZGVyaXZlKHRoaXMuZ2V0Q29pbktleShcIkVPU1wiKSk7XG4gICAgY29uc3QgZWxsaXB0aWNLZXlQYWlyID0gZWNkc2Eua2V5RnJvbVByaXZhdGUoY2hpbGROb2RlLnByaXZhdGVLZXkpO1xuICAgIGNvbnN0IGVvc1ByaXZhdGVLZXkgPSBQcml2YXRlS2V5LmZyb21FbGxpcHRpYyhcbiAgICAgIGVsbGlwdGljS2V5UGFpcixcbiAgICAgIEtleVR5cGUuazEsXG4gICAgICBlY2RzYVxuICAgICk7XG4gICAgcmV0dXJuIGVvc1ByaXZhdGVLZXkudG9MZWdhY3lTdHJpbmcoKTtcbiAgfVxuXG4gIHB1YmxpYyBnZXRFT1NQdWJsaWNLZXkoKTogc3RyaW5nIHtcbiAgICBjb25zdCBjaGlsZE5vZGUgPSB0aGlzLm1hc3Rlck5vZGUuZGVyaXZlKHRoaXMuZ2V0Q29pbktleShcIkVPU1wiKSk7XG4gICAgY29uc3QgZWxsaXB0aWNLZXlQYWlyID0gZWNkc2Eua2V5RnJvbVByaXZhdGUoY2hpbGROb2RlLnByaXZhdGVLZXkpO1xuICAgIGNvbnN0IGVvc1B1YmxpY0tleSA9IFB1YmxpY0tleS5mcm9tRWxsaXB0aWMoXG4gICAgICBlbGxpcHRpY0tleVBhaXIsXG4gICAgICBLZXlUeXBlLmsxLFxuICAgICAgZWNkc2FcbiAgICApO1xuICAgIHJldHVybiB0aGlzLmNvbnZlcnRUb0Vvc0xlZ2FjeVB1YmxpY0tleShlb3NQdWJsaWNLZXkpO1xuICB9XG5cbiAgcHJpdmF0ZSBnZXRDb2luS2V5KGNvaW5UeXBlOiBDb2luVHlwZSk6IHN0cmluZyB7XG4gICAgc3dpdGNoIChjb2luVHlwZSkge1xuICAgICAgY2FzZSBcIkJUQ1wiOiB7XG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgfVxuICAgICAgY2FzZSBcIkVPU1wiOiB7XG4gICAgICAgIHJldHVybiAnbS80NFxcJy8xOTRcXCcvMFxcJy8wLzAnO1xuICAgICAgfVxuICAgICAgY2FzZSBcIkVUSFwiOiB7XG4gICAgICAgIHJldHVybiAnbS80NFxcJy82MFxcJy8xXFwnLzAvMCc7XG4gICAgICB9XG4gICAgICBjYXNlIFwiWFJQXCI6IHtcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBjb252ZXJ0VG9Fb3NMZWdhY3lQdWJsaWNLZXkocHVibGljS2V5OiBQdWJsaWNLZXkpOiBzdHJpbmcge1xuICAgIGNvbnN0IGtleVN0cmluZyA9IHB1YmxpY0tleS50b1N0cmluZygpO1xuICAgIGNvbnN0IGtleSA9IHN0cmluZ1RvUHVibGljS2V5KGtleVN0cmluZyk7XG4gICAgaWYgKGtleS50eXBlID09IEtleVR5cGUuazEgJiYga2V5LmRhdGEubGVuZ3RoID09PSBwdWJsaWNLZXlEYXRhU2l6ZSkge1xuICAgICAgY29uc3QgZGlnZXN0ID0gbmV3IFVpbnQ4QXJyYXkocmlwZW1kMTYwKGtleS5kYXRhKSk7XG4gICAgICBjb25zdCB3aG9sZSA9IG5ldyBVaW50OEFycmF5KHB1YmxpY0tleURhdGFTaXplICsgNCk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHB1YmxpY0tleURhdGFTaXplOyArK2kpIHdob2xlW2ldID0ga2V5LmRhdGFbaV07XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDQ7ICsraSkgd2hvbGVbaSArIHB1YmxpY0tleURhdGFTaXplXSA9IGRpZ2VzdFtpXTtcbiAgICAgIHJldHVybiBcIkVPU1wiICsgYmluYXJ5VG9CYXNlNTgod2hvbGUpO1xuICAgIH0gZWxzZSBpZiAoa2V5LnR5cGUgPT0gS2V5VHlwZS5yMSAmJiBrZXkuZGF0YS5sZW5ndGggPT09IHB1YmxpY0tleURhdGFTaXplKSB7XG4gICAgICByZXR1cm4ga2V5U3RyaW5nO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bnJlY29nbml6ZWQgcHVibGljIGtleSBmb3JtYXRcIik7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFdhbGxldDtcbiJdLCJuYW1lcyI6WyJfX2Fzc2lnbiIsIk9iamVjdCIsImFzc2lnbiIsInQiLCJzIiwiaSIsIm4iLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJwIiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiYXBwbHkiLCJfX2F3YWl0ZXIiLCJ0aGlzQXJnIiwiX2FyZ3VtZW50cyIsIlAiLCJnZW5lcmF0b3IiLCJhZG9wdCIsInZhbHVlIiwicmVzb2x2ZSIsIlByb21pc2UiLCJyZWplY3QiLCJmdWxmaWxsZWQiLCJzdGVwIiwibmV4dCIsImUiLCJyZWplY3RlZCIsInJlc3VsdCIsImRvbmUiLCJ0aGVuIiwiX19nZW5lcmF0b3IiLCJib2R5IiwiXyIsImxhYmVsIiwic2VudCIsInRyeXMiLCJvcHMiLCJmIiwieSIsImciLCJ2ZXJiIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJ2Iiwib3AiLCJUeXBlRXJyb3IiLCJwb3AiLCJwdXNoIiwid2ViY3J5cHRvLkNyeXB0byIsImVsbGlwdGljLmVjIiwiYmlwMzkubW5lbW9uaWNUb1NlZWRTeW5jIiwiSERLZXkuZnJvbU1hc3RlclNlZWQiLCJiaXAzOS5nZW5lcmF0ZU1uZW1vbmljIiwid2lmLmVuY29kZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQStCTyxJQUFJQSxPQUFRLEdBQUcsb0JBQVc7QUFDN0JBLEVBQUFBLE9BQVEsR0FBR0MsTUFBTSxDQUFDQyxNQUFQLElBQWlCLFNBQVNGLFFBQVQsQ0FBa0JHLENBQWxCLEVBQXFCO0FBQzdDLFNBQUssSUFBSUMsQ0FBSixFQUFPQyxDQUFDLEdBQUcsQ0FBWCxFQUFjQyxDQUFDLEdBQUdDLFNBQVMsQ0FBQ0MsTUFBakMsRUFBeUNILENBQUMsR0FBR0MsQ0FBN0MsRUFBZ0RELENBQUMsRUFB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
