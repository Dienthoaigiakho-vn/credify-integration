export class Signing {
  public get privateKey(): Buffer;
  public get publicKey(): Buffer;
  public generateKeyPair(): void;
  public importPrivateKey(pem: string, password?: string): void;
  public importPrivateKeyInBase64Url(pem: string, password?: string): void;
  public importPublicKey(pem: string): void;
  public importPublicKeyInBase64Url(pem: string): void;
  public sign(
    message: string,
    option?: {
      input?: "base64" | "utf8" | "hex";
      output?: "base64" | "utf8" | "hex";
    }
  ): string;
  public verify(
    message: string,
    signature: string,
    option?: { encode: "base64" | "base64Url" }
  ): boolean;
  public exportPrivateKey(password?: string): string;
  public exportPublicKey(): string;
  public exportPrivateKeyInBase64Url(): string;
  public exportPublicKeyInBase64Url(): string;
}

export class EcdsaKey {
  public get privateKey(): CryptoKey;
  public get publicKey(): CryptoKey;
  public generateKeyPair(): Promise<void>;
  public importPrivateKey(pem: string, password?: string): Promise<void>;
  public importPrivateKeyInBase64Url(
    pem: string,
    password?: string
  ): Promise<void>;
  public importPublicKey(pem: string): Promise<void>;
  public importPublicKeyInBase64Url(pem: string): Promise<void>;
  public sign(
    message: string,
    option?: {
      input?: "base64" | "utf8" | "hex";
      output?: "base64" | "utf8" | "hex";
    }
  ): Promise<string>;
  public verify(
    message: string,
    signature: string,
    option?: { encode: "base64" | "base64Url" }
  ): Promise<boolean>;
  public exportPrivateKey(password?: string): Promise<string>;
  public exportPrivateKeyInBase64Url(): Promise<string>;
  public exportPublicKey(): Promise<string>;
  public exportPublicKeyInBase64Url(): Promise<string>;
}

export class Encryption {
  public get privateKey(): CryptoKey;
  public get publicKey(): CryptoKey;
  public generateKeyPair(): Promise<void>;
  public importPrivateKey(pem: string, password?: string): Promise<void>;
  public importPrivateKeyInBase64Url(
    pem: string,
    password?: string
  ): Promise<void>;
  public importPublicKey(pem: string): Promise<void>;
  public importPublicKeyInBase64Url(pem: string): Promise<void>;
  public encrypt(data: Buffer): Promise<Buffer>;
  public encryptStringToBase64UrlString(message: string): Promise<string>;
  public encryptFieldByField(plain: any): Promise<any>;
  public decrypt(cipher: Buffer): Promise<string>;
  public decryptBase64UrlStringToString(cipher: string): Promise<string>;
  public decryptFieldByField(cipher: any): Promise<any>;
  public exportPrivateKey(password?: string): Promise<string>;
  public exportPrivateKeyInBase64Url(): Promise<string>;
  public exportPublicKey(): Promise<string>;
  public exportPublicKeyInBase64Url(): Promise<string>;
}

export type CoinType = "BTC" | "EOS" | "ETH" | "XRP";

export class Wallet {
  public constructor(mnemonic: string);
  public static create(): Wallet;
  public getMnemonic(): string;
  public getMasterPrivateKey(): string;
  public getMasterPublicKey(): string;
  public getEOSPrivateKey(): string;
  public getEOSPublicKey(): string;
}

export function parseJwt(token: string): JWTType;
export function generateJwt(signing: Signing, payload?: any): string;
export function generateApprovalToken(
  signing: Signing,
  clientId: string,
  entityId: string,
  approvedScopes: string[],
  offerCode?: string
): string;
export function generateRequestToken(
  signing: Signing,
  encryptionPublicKey: string,
  scopes: string[],
  offerCode?: string
): string;
export function generateIdentityToken(
  signing: Signing,
  entityId: string,
  identitySource: string,
  identityHash: string
): string;
export function generateClaimToken(
  signing: Signing,
  providerId: string,
  entityId: string,
  scopeName: string,
  claim: object
);
export function generateDisbursementToken(
  signing: Signing,
  providerId: string,
  entityId: string,
  claims: { [key: string]: any },
  publicKey?: string
): Promise<string>;
export function verifyJwt(jwt: JWTType, signing: Signing): boolean;

export function sha256(value: any): string;
export function generateCommitment(bytes?: number): string;
export function camelize(o: any): any;
export function decamelize(o: any): any;
export function unifyJsonData(unorderedObject: any): any;
export function base64ToBase64UrlEncoded(base64: string): string;
export function base64UrlToBase64Encoded(base64Url: string): string;

export interface JWTHeader {
  alg: string;
  typ: string;
}

export interface JWTPayload {
  exp: number;
  iat: number;
  signing_key: string;
  scp: string[];
}

export interface JWTType {
  header: JWTHeader;
  headerEncoded: string;
  payload: JWTPayload;
  payloadEncoded: string;
  signature: string;
}
